{"ast":null,"code":"import PointerLockControls from './libs/pointer-lock-controls';\nexport function initPointerLock(camera, rendererElement) {\n  var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;\n\n  var pointerlockchange = function pointerlockchange(event) {\n    controls.enabled = !controls.enabled;\n  };\n\n  var requestPointerLockEvent = function requestPointerLockEvent(event) {\n    document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock || document.body.webkitRequestPointerLock;\n    document.body.requestPointerLock();\n  };\n\n  if (havePointerLock) {\n    document.addEventListener('pointerlockchange', pointerlockchange, false);\n    document.addEventListener('mozpointerlockchange', pointerlockchange, false);\n    document.addEventListener('webkitpointerlockchange', pointerlockchange, false);\n    rendererElement.addEventListener('click', requestPointerLockEvent);\n  } else {\n    console.log('Your browser doesn\\'t seem to support Pointer Lock API');\n  }\n\n  var controls = new PointerLockControls(camera);\n  return {\n    controls: controls,\n    pointerlockChangeEvent: pointerlockchange,\n    requestPointerLockEvent: requestPointerLockEvent\n  };\n}\n/* Funzione per il calcolo delle collisioni con gli oggetti contenuti all'interno di un array.\n * L'idea è quella di utilizzare il ray casting. Per tenere conto del fatto che ci possiamo\n * muovere nelle quattro direzioni, applico una matrice di rotazione alla direzione verso la\n * quale l'oggetto del pointer lock è orientato. */\n\nfunction collision(controls, collisionArray) {\n  var rotationMatrix = void 0;\n  var cameraDirection = controls.getDirection(new THREE.Vector3(0, 0, 0)).clone();\n\n  if (controls.moveForward()) {// Nothing to do!\n  } else if (controls.moveBackward()) {\n    rotationMatrix = new THREE.Matrix4();\n    rotationMatrix.makeRotationY(180 * Math.PI / 180);\n  } else if (controls.moveLeft()) {\n    rotationMatrix = new THREE.Matrix4();\n    rotationMatrix.makeRotationY(90 * Math.PI / 180);\n  } else if (controls.moveRight()) {\n    rotationMatrix = new THREE.Matrix4();\n    rotationMatrix.makeRotationY((360 - 90) * Math.PI / 180);\n  } else return;\n\n  if (rotationMatrix !== undefined) {\n    cameraDirection.applyMatrix4(rotationMatrix);\n  }\n\n  var rayCaster = new THREE.Raycaster(controls.getObject().position, cameraDirection.normalize());\n  var intersects = rayCaster.intersectObjects(collisionArray, true);\n\n  if (intersects.length > 0 && intersects[0].distance < 10) {\n    return true;\n  }\n\n  return false;\n}\n/* Funzione meno raffinata per il calcolo delle collisioni.\n * In pratica viene definita una bounding geometry (in questo caso la skymap) e poi vengono fatti\n * partire una serie di raggi dall'object del controller fino ai vertici di questa geometria. Se uno di questi interseca\n * uno degli oggetti dei quali vogliamo controllare la collisione, allora la funzione restituirà il valore true */\n\n/*\n function collision(object, boundingGeometry, collisionArray ) {\n\n for (let vertexIndex = 0; vertexIndex < boundingGeometry.geometry.vertices.length; vertexIndex++)\t{\n let localVertex = boundingGeometry.geometry.vertices[vertexIndex].clone();\n let globalVertex = localVertex.applyMatrix4( object.matrix );\n let directionVector = globalVertex.sub( object.position );\n\n let ray = new THREE.Raycaster(object.position, directionVector.clone().normalize());\n let collisionResults = ray.intersectObjects(collisionArray, true);\n if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() - 1293) {\n console.log(\"collisione: \",collisionResults[0].distance,\" \",directionVector.length()-1293);\n return true;\n }\n }\n return false;\n }\n */\n\n/* Questa funzione si occupa di determinare se il controllo si trova su un oggetto, in caso negativo cade verso il basso\n * (vedi esempio pointer lock) */\n\n\nfunction translateY(controls, ray, objects) {\n  controls.isOnObject(false);\n  ray.ray.origin.copy(controls.getObject().position);\n  ray.ray.origin.y -= 10;\n  var intersections = ray.intersectObjects(objects, true);\n\n  if (intersections.length > 0) {\n    var distance = intersections[0].distance;\n\n    if (distance > 0 && distance < 10) {\n      controls.isOnObject(true);\n    }\n  }\n}\n/* Queste funzioni bloccano o sbloccano il movimento del controller (utili in caso di collisione) */\n\n\nfunction lockDirection(controls) {\n  if (controls.moveForward()) {\n    controls.lockMoveForward(true);\n  } else if (controls.moveBackward()) {\n    controls.lockMoveBackward(true);\n  } else if (controls.moveLeft()) {\n    controls.lockMoveLeft(true);\n  } else if (controls.moveRight()) {\n    controls.lockMoveRight(true);\n  }\n}\n\nfunction unlockAllDirection(controls) {\n  controls.lockMoveForward(false);\n  controls.lockMoveBackward(false);\n  controls.lockMoveLeft(false);\n  controls.lockMoveRight(false);\n}","map":{"version":3,"sources":["/home/srihari/Desktop/Sparkplug_PandemicSparks/grid/node_modules/react-planner/es/components/viewer3d/pointer-lock-navigation.js"],"names":["PointerLockControls","initPointerLock","camera","rendererElement","havePointerLock","document","pointerlockchange","event","controls","enabled","requestPointerLockEvent","body","requestPointerLock","mozRequestPointerLock","webkitRequestPointerLock","addEventListener","console","log","pointerlockChangeEvent","collision","collisionArray","rotationMatrix","cameraDirection","getDirection","THREE","Vector3","clone","moveForward","moveBackward","Matrix4","makeRotationY","Math","PI","moveLeft","moveRight","undefined","applyMatrix4","rayCaster","Raycaster","getObject","position","normalize","intersects","intersectObjects","length","distance","translateY","ray","objects","isOnObject","origin","copy","y","intersections","lockDirection","lockMoveForward","lockMoveBackward","lockMoveLeft","lockMoveRight","unlockAllDirection"],"mappings":"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","sourcesContent":["import PointerLockControls from './libs/pointer-lock-controls';\n\nexport function initPointerLock(camera, rendererElement) {\n\n  var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;\n\n  var pointerlockchange = function pointerlockchange(event) {\n    controls.enabled = !controls.enabled;\n  };\n\n  var requestPointerLockEvent = function requestPointerLockEvent(event) {\n    document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock || document.body.webkitRequestPointerLock;\n    document.body.requestPointerLock();\n  };\n\n  if (havePointerLock) {\n\n    document.addEventListener('pointerlockchange', pointerlockchange, false);\n    document.addEventListener('mozpointerlockchange', pointerlockchange, false);\n    document.addEventListener('webkitpointerlockchange', pointerlockchange, false);\n    rendererElement.addEventListener('click', requestPointerLockEvent);\n  } else {\n    console.log('Your browser doesn\\'t seem to support Pointer Lock API');\n  }\n\n  var controls = new PointerLockControls(camera);\n  return { controls: controls, pointerlockChangeEvent: pointerlockchange, requestPointerLockEvent: requestPointerLockEvent };\n}\n\n/* Funzione per il calcolo delle collisioni con gli oggetti contenuti all'interno di un array.\n * L'idea è quella di utilizzare il ray casting. Per tenere conto del fatto che ci possiamo\n * muovere nelle quattro direzioni, applico una matrice di rotazione alla direzione verso la\n * quale l'oggetto del pointer lock è orientato. */\n\nfunction collision(controls, collisionArray) {\n\n  var rotationMatrix = void 0;\n  var cameraDirection = controls.getDirection(new THREE.Vector3(0, 0, 0)).clone();\n\n  if (controls.moveForward()) {\n    // Nothing to do!\n  } else if (controls.moveBackward()) {\n    rotationMatrix = new THREE.Matrix4();\n    rotationMatrix.makeRotationY(180 * Math.PI / 180);\n  } else if (controls.moveLeft()) {\n    rotationMatrix = new THREE.Matrix4();\n    rotationMatrix.makeRotationY(90 * Math.PI / 180);\n  } else if (controls.moveRight()) {\n    rotationMatrix = new THREE.Matrix4();\n    rotationMatrix.makeRotationY((360 - 90) * Math.PI / 180);\n  } else return;\n\n  if (rotationMatrix !== undefined) {\n    cameraDirection.applyMatrix4(rotationMatrix);\n  }\n  var rayCaster = new THREE.Raycaster(controls.getObject().position, cameraDirection.normalize());\n  var intersects = rayCaster.intersectObjects(collisionArray, true);\n\n  if (intersects.length > 0 && intersects[0].distance < 10) {\n    return true;\n  }\n\n  return false;\n}\n\n/* Funzione meno raffinata per il calcolo delle collisioni.\n * In pratica viene definita una bounding geometry (in questo caso la skymap) e poi vengono fatti\n * partire una serie di raggi dall'object del controller fino ai vertici di questa geometria. Se uno di questi interseca\n * uno degli oggetti dei quali vogliamo controllare la collisione, allora la funzione restituirà il valore true */\n/*\n function collision(object, boundingGeometry, collisionArray ) {\n\n for (let vertexIndex = 0; vertexIndex < boundingGeometry.geometry.vertices.length; vertexIndex++)\t{\n let localVertex = boundingGeometry.geometry.vertices[vertexIndex].clone();\n let globalVertex = localVertex.applyMatrix4( object.matrix );\n let directionVector = globalVertex.sub( object.position );\n\n let ray = new THREE.Raycaster(object.position, directionVector.clone().normalize());\n let collisionResults = ray.intersectObjects(collisionArray, true);\n if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() - 1293) {\n console.log(\"collisione: \",collisionResults[0].distance,\" \",directionVector.length()-1293);\n return true;\n }\n }\n return false;\n }\n */\n\n/* Questa funzione si occupa di determinare se il controllo si trova su un oggetto, in caso negativo cade verso il basso\n * (vedi esempio pointer lock) */\n\nfunction translateY(controls, ray, objects) {\n\n  controls.isOnObject(false);\n  ray.ray.origin.copy(controls.getObject().position);\n  ray.ray.origin.y -= 10;\n  var intersections = ray.intersectObjects(objects, true);\n  if (intersections.length > 0) {\n    var distance = intersections[0].distance;\n    if (distance > 0 && distance < 10) {\n      controls.isOnObject(true);\n    }\n  }\n}\n\n/* Queste funzioni bloccano o sbloccano il movimento del controller (utili in caso di collisione) */\n\nfunction lockDirection(controls) {\n  if (controls.moveForward()) {\n    controls.lockMoveForward(true);\n  } else if (controls.moveBackward()) {\n    controls.lockMoveBackward(true);\n  } else if (controls.moveLeft()) {\n    controls.lockMoveLeft(true);\n  } else if (controls.moveRight()) {\n    controls.lockMoveRight(true);\n  }\n}\n\nfunction unlockAllDirection(controls) {\n  controls.lockMoveForward(false);\n  controls.lockMoveBackward(false);\n  controls.lockMoveLeft(false);\n  controls.lockMoveRight(false);\n}"]},"metadata":{},"sourceType":"module"}