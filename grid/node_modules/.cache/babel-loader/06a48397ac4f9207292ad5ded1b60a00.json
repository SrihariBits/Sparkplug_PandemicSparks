{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} //JS porting of this code http://www.geeksforgeeks.org/biconnected-components/\n\n\nfunction create_array(length) {\n  var array = [];\n\n  for (var i = 0; i < length; ++i) {\n    array.push([]);\n  }\n\n  return array;\n}\n\nvar Edge = function Edge(u, v) {\n  _classCallCheck(this, Edge);\n\n  this.u = u;\n  this.v = v;\n};\n\nvar Graph = function () {\n  function Graph(v) {\n    _classCallCheck(this, Graph);\n\n    this.count = 0; // count is number of biconnected components\n\n    this.subgraphs = []; //biconnected components\n\n    this.time = 0; // time is used to find discovery times\n\n    this.V = v; // No. of vertices\n\n    this.E = 0; // No. of Edges\n\n    this.adj = []; // Adjacency List\n\n    this.adj = create_array(v);\n  } //Function to add an edge into the graph\n\n\n  _createClass(Graph, [{\n    key: \"addEdge\",\n    value: function addEdge(v, w) {\n      this.adj[v].push(w);\n      this.E++;\n    } // A recursive function that finds and prints strongly connected\n    // components using DFS traversal\n    // u --> The vertex to be visited next\n    // disc[] --> Stores discovery times of visited vertices\n    // low[] -- >> earliest visited vertex (the vertex with minimum\n    //             discovery time) that can be reached from subtree\n    //             rooted with current vertex\n    // *st -- >> To store visited edges\n    // // A recursive function that finds and prints strongly connected\n    // components using DFS traversal\n    // u --> The vertex to be visited next\n    // disc[] --> Stores discovery times of visited vertices\n    // low[] -- >> earliest visited vertex (the vertex with minimum\n    //             discovery time) that can be reached from subtree\n    //             rooted with current vertex\n    // *st -- >> To store visited edges\n\n  }, {\n    key: \"_BCCUtil\",\n    value: function _BCCUtil(u, disc, low, st, parent) {\n      var _this = this; // Initialize discovery time and low value\n\n\n      disc[u] = low[u] = ++this.time;\n      this.children = 0; // Go through all vertices adjacent to this\n      // v is current adjacent of 'u'\n\n      this.adj[u].forEach(function (v) {\n        // If v is not visited yet, then recur for it\n        if (disc[v] == -1) {\n          _this.children++;\n          parent[v] = u; // store the edge in stack\n\n          st.push(new Edge(u, v));\n\n          _this._BCCUtil(v, disc, low, st, parent); // Check if the subtree rooted with 'v' has a\n          // connection to one of the ancestors of 'u'\n          // Case 1 -- per Strongly Connected Components Article\n\n\n          if (low[u] > low[v]) low[u] = low[v]; // If u is an articulation point,\n          // pop all edges from stack till u -- v\n\n          if (disc[u] == 1 && _this.children > 1 || disc[u] > 1 && low[v] >= disc[u]) {\n            var subgraph = [];\n\n            while (st[st.length - 1].u != u || st[st.length - 1].v != v) {\n              subgraph.push(st[st.length - 1]); //console.log(st[st.length - 1].u + \"--\" + st[st.length - 1].v + \" \");\n\n              st.splice(st.length - 1, 1);\n            }\n\n            subgraph.push(st[st.length - 1]); //console.log(st[st.length - 1].u + \"--\" + st[st.length - 1].v + \" \");\n\n            _this.subgraphs.push(subgraph);\n\n            subgraph = []; //console.log()\n\n            st.splice(st.length - 1, 1);\n            _this.count++;\n          }\n        } // Update low value of 'u' only of 'v' is still in stack\n        // (i.e. it's a back edge, not cross edge).\n        // Case 2 -- per Strongly Connected Components Article\n        else if (v != parent[u] && disc[v] < low[u]) {\n            if (low[u] > disc[v]) low[u] = disc[v];\n            st.push(new Edge(u, v));\n          }\n      });\n    }\n  }, {\n    key: \"BCC\",\n    value: function BCC() {\n      var V = this.V;\n      var disc = create_array(V);\n      var low = create_array(V);\n      var parent = create_array(V);\n      var st = []; // Initialize disc and low, and parent arrays\n\n      for (var i = 0; i < V; i++) {\n        disc[i] = -1;\n        low[i] = -1;\n        parent[i] = -1;\n      }\n\n      for (var _i = 0; _i < V; _i++) {\n        if (disc[_i] == -1) this._BCCUtil(_i, disc, low, st, parent);\n        var j = 0; // If stack is not empty, pop all edges from stack\n\n        var subgraph = [];\n\n        while (st.length > 0) {\n          j = 1;\n          subgraph.push(st[st.length - 1]); //console.log(st[st.length - 1].u + \"--\" + st[st.length - 1].v + \" \");\n\n          st.splice(st.length - 1, 1);\n        }\n\n        if (j == 1) {\n          this.subgraphs.push(subgraph);\n          subgraph = []; //console.log();\n\n          this.count++;\n        }\n      }\n    }\n  }]);\n\n  return Graph;\n}();\n\nmodule.exports = Graph;","map":{"version":3,"sources":["/home/srihari/Desktop/Sparkplug_PandemicSparks/grid/node_modules/react-planner/es/utils/graph.js"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","create_array","array","push","Edge","u","v","Graph","count","subgraphs","time","V","E","adj","value","addEdge","w","_BCCUtil","disc","low","st","parent","_this","children","forEach","subgraph","splice","BCC","_i","j","module","exports"],"mappings":"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","sourcesContent":["var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//JS porting of this code http://www.geeksforgeeks.org/biconnected-components/\n\nfunction create_array(length) {\n  var array = [];\n  for (var i = 0; i < length; ++i) {\n    array.push([]);\n  }\n  return array;\n}\n\nvar Edge = function Edge(u, v) {\n  _classCallCheck(this, Edge);\n\n  this.u = u;\n  this.v = v;\n};\n\nvar Graph = function () {\n  function Graph(v) {\n    _classCallCheck(this, Graph);\n\n    this.count = 0; // count is number of biconnected components\n    this.subgraphs = []; //biconnected components\n    this.time = 0; // time is used to find discovery times\n\n    this.V = v; // No. of vertices\n    this.E = 0; // No. of Edges\n    this.adj = []; // Adjacency List\n\n    this.adj = create_array(v);\n  }\n\n  //Function to add an edge into the graph\n\n\n  _createClass(Graph, [{\n    key: \"addEdge\",\n    value: function addEdge(v, w) {\n      this.adj[v].push(w);\n      this.E++;\n    }\n\n    // A recursive function that finds and prints strongly connected\n    // components using DFS traversal\n    // u --> The vertex to be visited next\n    // disc[] --> Stores discovery times of visited vertices\n    // low[] -- >> earliest visited vertex (the vertex with minimum\n    //             discovery time) that can be reached from subtree\n    //             rooted with current vertex\n    // *st -- >> To store visited edges\n    // // A recursive function that finds and prints strongly connected\n    // components using DFS traversal\n    // u --> The vertex to be visited next\n    // disc[] --> Stores discovery times of visited vertices\n    // low[] -- >> earliest visited vertex (the vertex with minimum\n    //             discovery time) that can be reached from subtree\n    //             rooted with current vertex\n    // *st -- >> To store visited edges\n\n  }, {\n    key: \"_BCCUtil\",\n    value: function _BCCUtil(u, disc, low, st, parent) {\n      var _this = this;\n\n      // Initialize discovery time and low value\n      disc[u] = low[u] = ++this.time;\n      this.children = 0;\n\n      // Go through all vertices adjacent to this\n      // v is current adjacent of 'u'\n      this.adj[u].forEach(function (v) {\n\n        // If v is not visited yet, then recur for it\n        if (disc[v] == -1) {\n          _this.children++;\n          parent[v] = u;\n\n          // store the edge in stack\n          st.push(new Edge(u, v));\n          _this._BCCUtil(v, disc, low, st, parent);\n\n          // Check if the subtree rooted with 'v' has a\n          // connection to one of the ancestors of 'u'\n          // Case 1 -- per Strongly Connected Components Article\n          if (low[u] > low[v]) low[u] = low[v];\n\n          // If u is an articulation point,\n          // pop all edges from stack till u -- v\n          if (disc[u] == 1 && _this.children > 1 || disc[u] > 1 && low[v] >= disc[u]) {\n            var subgraph = [];\n            while (st[st.length - 1].u != u || st[st.length - 1].v != v) {\n              subgraph.push(st[st.length - 1]);\n              //console.log(st[st.length - 1].u + \"--\" + st[st.length - 1].v + \" \");\n              st.splice(st.length - 1, 1);\n            }\n\n            subgraph.push(st[st.length - 1]);\n            //console.log(st[st.length - 1].u + \"--\" + st[st.length - 1].v + \" \");\n            _this.subgraphs.push(subgraph);\n            subgraph = [];\n            //console.log()\n            st.splice(st.length - 1, 1);\n\n            _this.count++;\n          }\n        }\n\n        // Update low value of 'u' only of 'v' is still in stack\n        // (i.e. it's a back edge, not cross edge).\n        // Case 2 -- per Strongly Connected Components Article\n        else if (v != parent[u] && disc[v] < low[u]) {\n            if (low[u] > disc[v]) low[u] = disc[v];\n            st.push(new Edge(u, v));\n          }\n      });\n    }\n  }, {\n    key: \"BCC\",\n    value: function BCC() {\n      var V = this.V;\n      var disc = create_array(V);\n      var low = create_array(V);\n      var parent = create_array(V);\n      var st = [];\n\n      // Initialize disc and low, and parent arrays\n      for (var i = 0; i < V; i++) {\n        disc[i] = -1;\n        low[i] = -1;\n        parent[i] = -1;\n      }\n\n      for (var _i = 0; _i < V; _i++) {\n        if (disc[_i] == -1) this._BCCUtil(_i, disc, low, st, parent);\n\n        var j = 0;\n\n        // If stack is not empty, pop all edges from stack\n        var subgraph = [];\n        while (st.length > 0) {\n          j = 1;\n          subgraph.push(st[st.length - 1]);\n          //console.log(st[st.length - 1].u + \"--\" + st[st.length - 1].v + \" \");\n          st.splice(st.length - 1, 1);\n        }\n\n        if (j == 1) {\n          this.subgraphs.push(subgraph);\n          subgraph = [];\n          //console.log();\n          this.count++;\n        }\n      }\n    }\n  }]);\n\n  return Graph;\n}();\n\nmodule.exports = Graph;"]},"metadata":{},"sourceType":"script"}