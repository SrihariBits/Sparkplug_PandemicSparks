{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/*jshint esversion: 6 */\n\n\nimport * as THREE from 'three';\nvar EPSILON = 1e-5,\n    COPLANAR = 0,\n    FRONT = 1,\n    BACK = 2,\n    SPANNING = 3;\n\nvar ThreeBSP = function () {\n  function ThreeBSP(geometry) {\n    _classCallCheck(this, ThreeBSP); // Convert THREE.Geometry to ThreeBSP\n\n\n    var i,\n        _length_i,\n        face,\n        vertex,\n        faceVertexUvs,\n        uvs,\n        polygon,\n        polygons = [],\n        tree;\n\n    this.Polygon = Polygon;\n    this.Vertex = Vertex;\n    this.Node = Node;\n\n    if (geometry instanceof THREE.Geometry) {\n      this.matrix = new THREE.Matrix4();\n    } else if (geometry instanceof THREE.Mesh) {\n      // #todo: add hierarchy support\n      geometry.updateMatrix();\n      this.matrix = geometry.matrix.clone();\n      geometry = geometry.geometry;\n    } else if (geometry instanceof Node) {\n      this.tree = geometry;\n      this.matrix = new THREE.Matrix4();\n      return this;\n    } else {\n      throw 'ThreeBSP: Given geometry is unsupported';\n    }\n\n    for (i = 0, _length_i = geometry.faces.length; i < _length_i; i++) {\n      face = geometry.faces[i];\n      faceVertexUvs = geometry.faceVertexUvs[0][i];\n      polygon = new Polygon();\n\n      if (face instanceof THREE.Face3) {\n        vertex = geometry.vertices[face.a];\n        uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[0].x, faceVertexUvs[0].y) : null;\n        vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[0], uvs);\n        vertex.applyMatrix4(this.matrix);\n        polygon.vertices.push(vertex);\n        vertex = geometry.vertices[face.b];\n        uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[1].x, faceVertexUvs[1].y) : null;\n        vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[1], uvs);\n        vertex.applyMatrix4(this.matrix);\n        polygon.vertices.push(vertex);\n        vertex = geometry.vertices[face.c];\n        uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[2].x, faceVertexUvs[2].y) : null;\n        vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[2], uvs);\n        vertex.applyMatrix4(this.matrix);\n        polygon.vertices.push(vertex);\n      } else if (_typeof(THREE.Face4)) {\n        vertex = geometry.vertices[face.a];\n        uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[0].x, faceVertexUvs[0].y) : null;\n        vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[0], uvs);\n        vertex.applyMatrix4(this.matrix);\n        polygon.vertices.push(vertex);\n        vertex = geometry.vertices[face.b];\n        uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[1].x, faceVertexUvs[1].y) : null;\n        vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[1], uvs);\n        vertex.applyMatrix4(this.matrix);\n        polygon.vertices.push(vertex);\n        vertex = geometry.vertices[face.c];\n        uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[2].x, faceVertexUvs[2].y) : null;\n        vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[2], uvs);\n        vertex.applyMatrix4(this.matrix);\n        polygon.vertices.push(vertex);\n        vertex = geometry.vertices[face.d];\n        uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[3].x, faceVertexUvs[3].y) : null;\n        vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[3], uvs);\n        vertex.applyMatrix4(this.matrix);\n        polygon.vertices.push(vertex);\n      } else {\n        throw 'Invalid face type at index ' + i;\n      }\n\n      polygon.calculateProperties();\n      polygons.push(polygon);\n    }\n\n    this.tree = new Node(polygons);\n  }\n\n  _createClass(ThreeBSP, [{\n    key: 'subtract',\n    value: function subtract(other_tree) {\n      var a = this.tree.clone(),\n          b = other_tree.tree.clone();\n      a.invert();\n      a.clipTo(b);\n      b.clipTo(a);\n      b.invert();\n      b.clipTo(a);\n      b.invert();\n      a.build(b.allPolygons());\n      a.invert();\n      a = new ThreeBSP(a);\n      a.matrix = this.matrix;\n      return a;\n    }\n  }, {\n    key: 'union',\n    value: function union(other_tree) {\n      var a = this.tree.clone(),\n          b = other_tree.tree.clone();\n      a.clipTo(b);\n      b.clipTo(a);\n      b.invert();\n      b.clipTo(a);\n      b.invert();\n      a.build(b.allPolygons());\n      a = new ThreeBSP(a);\n      a.matrix = this.matrix;\n      return a;\n    }\n  }, {\n    key: 'intersect',\n    value: function intersect(other_tree) {\n      var a = this.tree.clone(),\n          b = other_tree.tree.clone();\n      a.invert();\n      b.clipTo(a);\n      b.invert();\n      a.clipTo(b);\n      b.clipTo(a);\n      a.build(b.allPolygons());\n      a.invert();\n      a = new ThreeBSP(a);\n      a.matrix = this.matrix;\n      return a;\n    }\n  }, {\n    key: 'toGeometry',\n    value: function toGeometry() {\n      var i,\n          j,\n          matrix = new THREE.Matrix4().getInverse(this.matrix),\n          geometry = new THREE.Geometry(),\n          polygons = this.tree.allPolygons(),\n          polygon_count = polygons.length,\n          polygon,\n          polygon_vertice_count,\n          vertice_dict = {},\n          vertex_idx_a,\n          vertex_idx_b,\n          vertex_idx_c,\n          vertex,\n          face,\n          verticeUvs;\n\n      for (i = 0; i < polygon_count; i++) {\n        polygon = polygons[i];\n        polygon_vertice_count = polygon.vertices.length;\n\n        for (j = 2; j < polygon_vertice_count; j++) {\n          verticeUvs = [];\n          vertex = polygon.vertices[0];\n          verticeUvs.push(new THREE.Vector2(vertex.uv.x, vertex.uv.y));\n          vertex = new THREE.Vector3(vertex.x, vertex.y, vertex.z);\n          vertex.applyMatrix4(matrix);\n\n          if (typeof vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] !== 'undefined') {\n            vertex_idx_a = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z];\n          } else {\n            geometry.vertices.push(vertex);\n            vertex_idx_a = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] = geometry.vertices.length - 1;\n          }\n\n          vertex = polygon.vertices[j - 1];\n          verticeUvs.push(new THREE.Vector2(vertex.uv.x, vertex.uv.y));\n          vertex = new THREE.Vector3(vertex.x, vertex.y, vertex.z);\n          vertex.applyMatrix4(matrix);\n\n          if (typeof vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] !== 'undefined') {\n            vertex_idx_b = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z];\n          } else {\n            geometry.vertices.push(vertex);\n            vertex_idx_b = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] = geometry.vertices.length - 1;\n          }\n\n          vertex = polygon.vertices[j];\n          verticeUvs.push(new THREE.Vector2(vertex.uv.x, vertex.uv.y));\n          vertex = new THREE.Vector3(vertex.x, vertex.y, vertex.z);\n          vertex.applyMatrix4(matrix);\n\n          if (typeof vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] !== 'undefined') {\n            vertex_idx_c = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z];\n          } else {\n            geometry.vertices.push(vertex);\n            vertex_idx_c = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] = geometry.vertices.length - 1;\n          }\n\n          face = new THREE.Face3(vertex_idx_a, vertex_idx_b, vertex_idx_c, new THREE.Vector3(polygon.normal.x, polygon.normal.y, polygon.normal.z));\n          geometry.faces.push(face);\n          geometry.faceVertexUvs[0].push(verticeUvs);\n        }\n      }\n\n      return geometry;\n    }\n  }, {\n    key: 'toMesh',\n    value: function toMesh(material) {\n      var geometry = this.toGeometry(),\n          mesh = new THREE.Mesh(geometry, material);\n      mesh.position.setFromMatrixPosition(this.matrix);\n      mesh.rotation.setFromRotationMatrix(this.matrix);\n      return mesh;\n    }\n  }]);\n\n  return ThreeBSP;\n}();\n\nexport default ThreeBSP;\n\nvar Polygon = function () {\n  function Polygon(vertices, normal, w) {\n    _classCallCheck(this, Polygon);\n\n    if (!(vertices instanceof Array)) {\n      vertices = [];\n    }\n\n    this.vertices = vertices;\n\n    if (vertices.length > 0) {\n      this.calculateProperties();\n    } else {\n      this.normal = this.w = undefined;\n    }\n  }\n\n  _createClass(Polygon, [{\n    key: 'calculateProperties',\n    value: function calculateProperties() {\n      var a = this.vertices[0],\n          b = this.vertices[1],\n          c = this.vertices[2];\n      this.normal = b.clone().subtract(a).cross(c.clone().subtract(a)).normalize();\n      this.w = this.normal.clone().dot(a);\n      return this;\n    }\n  }, {\n    key: 'clone',\n    value: function clone() {\n      var i,\n          vertice_count,\n          polygon = new Polygon();\n\n      for (i = 0, vertice_count = this.vertices.length; i < vertice_count; i++) {\n        polygon.vertices.push(this.vertices[i].clone());\n      }\n\n      polygon.calculateProperties();\n      return polygon;\n    }\n  }, {\n    key: 'flip',\n    value: function flip() {\n      var i,\n          vertices = [];\n      this.normal.multiplyScalar(-1);\n      this.w *= -1;\n\n      for (i = this.vertices.length - 1; i >= 0; i--) {\n        vertices.push(this.vertices[i]);\n      }\n\n      this.vertices = vertices;\n      return this;\n    }\n  }, {\n    key: 'classifyVertex',\n    value: function classifyVertex(vertex) {\n      var side_value = this.normal.dot(vertex) - this.w;\n\n      if (side_value < -EPSILON) {\n        return BACK;\n      } else if (side_value > EPSILON) {\n        return FRONT;\n      } else {\n        return COPLANAR;\n      }\n    }\n  }, {\n    key: 'classifySide',\n    value: function classifySide(polygon) {\n      var i,\n          vertex,\n          classification,\n          num_positive = 0,\n          num_negative = 0,\n          vertice_count = polygon.vertices.length;\n\n      for (i = 0; i < vertice_count; i++) {\n        vertex = polygon.vertices[i];\n        classification = this.classifyVertex(vertex);\n\n        if (classification === FRONT) {\n          num_positive++;\n        } else if (classification === BACK) {\n          num_negative++;\n        }\n      }\n\n      if (num_positive > 0 && num_negative === 0) {\n        return FRONT;\n      } else if (num_positive === 0 && num_negative > 0) {\n        return BACK;\n      } else if (num_positive === 0 && num_negative === 0) {\n        return COPLANAR;\n      } else {\n        return SPANNING;\n      }\n    }\n  }, {\n    key: 'splitPolygon',\n    value: function splitPolygon(polygon, coplanar_front, coplanar_back, front, back) {\n      var classification = this.classifySide(polygon);\n\n      if (classification === COPLANAR) {\n        (this.normal.dot(polygon.normal) > 0 ? coplanar_front : coplanar_back).push(polygon);\n      } else if (classification === FRONT) {\n        front.push(polygon);\n      } else if (classification === BACK) {\n        back.push(polygon);\n      } else {\n        var vertice_count,\n            i,\n            j,\n            ti,\n            tj,\n            vi,\n            vj,\n            t,\n            v,\n            f = [],\n            b = [];\n\n        for (i = 0, vertice_count = polygon.vertices.length; i < vertice_count; i++) {\n          j = (i + 1) % vertice_count;\n          vi = polygon.vertices[i];\n          vj = polygon.vertices[j];\n          ti = this.classifyVertex(vi);\n          tj = this.classifyVertex(vj);\n          if (ti != BACK) f.push(vi);\n          if (ti != FRONT) b.push(vi);\n\n          if ((ti | tj) === SPANNING) {\n            t = (this.w - this.normal.dot(vi)) / this.normal.dot(vj.clone().subtract(vi));\n            v = vi.interpolate(vj, t);\n            f.push(v);\n            b.push(v);\n          }\n        }\n\n        if (f.length >= 3) front.push(new Polygon(f).calculateProperties());\n        if (b.length >= 3) back.push(new Polygon(b).calculateProperties());\n      }\n    }\n  }]);\n\n  return Polygon;\n}();\n\nvar Vertex = function () {\n  function Vertex(x, y, z, normal, uv) {\n    _classCallCheck(this, Vertex);\n\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.normal = normal || new THREE.Vector3();\n    this.uv = uv || new THREE.Vector2();\n  }\n\n  _createClass(Vertex, [{\n    key: 'clone',\n    value: function clone() {\n      return new Vertex(this.x, this.y, this.z, this.normal.clone(), this.uv.clone());\n    }\n  }, {\n    key: 'add',\n    value: function add(vertex) {\n      this.x += vertex.x;\n      this.y += vertex.y;\n      this.z += vertex.z;\n      return this;\n    }\n  }, {\n    key: 'subtract',\n    value: function subtract(vertex) {\n      this.x -= vertex.x;\n      this.y -= vertex.y;\n      this.z -= vertex.z;\n      return this;\n    }\n  }, {\n    key: 'multiplyScalar',\n    value: function multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      return this;\n    }\n  }, {\n    key: 'cross',\n    value: function cross(vertex) {\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      this.x = y * vertex.z - z * vertex.y;\n      this.y = z * vertex.x - x * vertex.z;\n      this.z = x * vertex.y - y * vertex.x;\n      return this;\n    }\n  }, {\n    key: 'normalize',\n    value: function normalize() {\n      var length = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n      this.x /= length;\n      this.y /= length;\n      this.z /= length;\n      return this;\n    }\n  }, {\n    key: 'dot',\n    value: function dot(vertex) {\n      return this.x * vertex.x + this.y * vertex.y + this.z * vertex.z;\n    }\n  }, {\n    key: 'lerp',\n    value: function lerp(a, t) {\n      this.add(a.clone().subtract(this).multiplyScalar(t));\n      this.normal.add(a.normal.clone().sub(this.normal).multiplyScalar(t));\n      this.uv.add(a.uv.clone().sub(this.uv).multiplyScalar(t));\n      return this;\n    }\n  }, {\n    key: 'interpolate',\n    value: function interpolate(other, t) {\n      return this.clone().lerp(other, t);\n    }\n  }, {\n    key: 'applyMatrix4',\n    value: function applyMatrix4(m) {\n      // input: THREE.Matrix4 affine matrix\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      var e = m.elements;\n      this.x = e[0] * x + e[4] * y + e[8] * z + e[12];\n      this.y = e[1] * x + e[5] * y + e[9] * z + e[13];\n      this.z = e[2] * x + e[6] * y + e[10] * z + e[14];\n      return this;\n    }\n  }]);\n\n  return Vertex;\n}();\n\nvar Node = function () {\n  function Node(polygons) {\n    _classCallCheck(this, Node);\n\n    var i,\n        polygon_count,\n        front = [],\n        back = [];\n    this.polygons = [];\n    this.front = this.back = undefined;\n    if (!(polygons instanceof Array) || polygons.length === 0) return;\n    this.divider = polygons[0].clone();\n\n    for (i = 0, polygon_count = polygons.length; i < polygon_count; i++) {\n      this.divider.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\n    }\n\n    if (front.length > 0) {\n      this.front = new Node(front);\n    }\n\n    if (back.length > 0) {\n      this.back = new Node(back);\n    }\n  }\n\n  _createClass(Node, [{\n    key: 'isConvex',\n    value: function isConvex(polygons) {\n      var i, j;\n\n      for (i = 0; i < polygons.length; i++) {\n        for (j = 0; j < polygons.length; j++) {\n          if (i !== j && polygons[i].classifySide(polygons[j]) !== BACK) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'build',\n    value: function build(polygons) {\n      var i,\n          polygon_count,\n          front = [],\n          back = [];\n\n      if (!this.divider) {\n        this.divider = polygons[0].clone();\n      }\n\n      for (i = 0, polygon_count = polygons.length; i < polygon_count; i++) {\n        this.divider.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\n      }\n\n      if (front.length > 0) {\n        if (!this.front) this.front = new Node();\n        this.front.build(front);\n      }\n\n      if (back.length > 0) {\n        if (!this.back) this.back = new Node();\n        this.back.build(back);\n      }\n    }\n  }, {\n    key: 'allPolygons',\n    value: function allPolygons() {\n      var polygons = this.polygons.slice();\n      if (this.front) polygons = polygons.concat(this.front.allPolygons());\n      if (this.back) polygons = polygons.concat(this.back.allPolygons());\n      return polygons;\n    }\n  }, {\n    key: 'clone',\n    value: function clone() {\n      var node = new Node();\n      node.divider = this.divider.clone();\n      node.polygons = this.polygons.map(function (polygon) {\n        return polygon.clone();\n      });\n      node.front = this.front && this.front.clone();\n      node.back = this.back && this.back.clone();\n      return node;\n    }\n  }, {\n    key: 'invert',\n    value: function invert() {\n      var i, polygon_count, temp;\n\n      for (i = 0, polygon_count = this.polygons.length; i < polygon_count; i++) {\n        this.polygons[i].flip();\n      }\n\n      this.divider.flip();\n      if (this.front) this.front.invert();\n      if (this.back) this.back.invert();\n      temp = this.front;\n      this.front = this.back;\n      this.back = temp;\n      return this;\n    }\n  }, {\n    key: 'clipPolygons',\n    value: function clipPolygons(polygons) {\n      var i, polygon_count, front, back;\n      if (!this.divider) return polygons.slice();\n      front = [];\n      back = [];\n\n      for (i = 0, polygon_count = polygons.length; i < polygon_count; i++) {\n        this.divider.splitPolygon(polygons[i], front, back, front, back);\n      }\n\n      if (this.front) front = this.front.clipPolygons(front);\n      if (this.back) back = this.back.clipPolygons(back);else back = [];\n      return front.concat(back);\n    }\n  }, {\n    key: 'clipTo',\n    value: function clipTo(node) {\n      this.polygons = node.clipPolygons(this.polygons);\n      if (this.front) this.front.clipTo(node);\n      if (this.back) this.back.clipTo(node);\n    }\n  }]);\n\n  return Node;\n}();\n\nwindow.ThreeBSP = ThreeBSP;","map":{"version":3,"sources":["/home/srihari/Desktop/Sparkplug_PandemicSparks/grid/node_modules/react-planner/es/utils/threeCSG.es6.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","_classCallCheck","instance","TypeError","THREE","EPSILON","COPLANAR","FRONT","BACK","SPANNING","ThreeBSP","geometry","_length_i","face","vertex","faceVertexUvs","uvs","polygon","polygons","tree","Polygon","Vertex","Node","Geometry","matrix","Matrix4","Mesh","updateMatrix","clone","faces","Face3","vertices","a","Vector2","x","y","z","vertexNormals","applyMatrix4","push","b","c","Face4","d","calculateProperties","value","subtract","other_tree","invert","clipTo","build","allPolygons","union","intersect","toGeometry","j","getInverse","polygon_count","polygon_vertice_count","vertice_dict","vertex_idx_a","vertex_idx_b","vertex_idx_c","verticeUvs","uv","Vector3","normal","toMesh","material","mesh","position","setFromMatrixPosition","rotation","setFromRotationMatrix","w","Array","undefined","cross","normalize","dot","vertice_count","flip","multiplyScalar","classifyVertex","side_value","classifySide","classification","num_positive","num_negative","splitPolygon","coplanar_front","coplanar_back","front","back","ti","tj","vi","vj","t","v","f","interpolate","add","scalar","Math","sqrt","lerp","sub","other","m","e","elements","divider","isConvex","slice","concat","node","map","temp","clipPolygons","window"],"mappings":"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","sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*jshint esversion: 6 */\nimport * as THREE from 'three';\n\nvar EPSILON = 1e-5,\n    COPLANAR = 0,\n    FRONT = 1,\n    BACK = 2,\n    SPANNING = 3;\n\nvar ThreeBSP = function () {\n    function ThreeBSP(geometry) {\n        _classCallCheck(this, ThreeBSP);\n\n        // Convert THREE.Geometry to ThreeBSP\n        var i,\n            _length_i,\n            face,\n            vertex,\n            faceVertexUvs,\n            uvs,\n            polygon,\n            polygons = [],\n            tree;\n\n        this.Polygon = Polygon;\n        this.Vertex = Vertex;\n        this.Node = Node;\n        if (geometry instanceof THREE.Geometry) {\n            this.matrix = new THREE.Matrix4();\n        } else if (geometry instanceof THREE.Mesh) {\n            // #todo: add hierarchy support\n            geometry.updateMatrix();\n            this.matrix = geometry.matrix.clone();\n            geometry = geometry.geometry;\n        } else if (geometry instanceof Node) {\n            this.tree = geometry;\n            this.matrix = new THREE.Matrix4();\n            return this;\n        } else {\n            throw 'ThreeBSP: Given geometry is unsupported';\n        }\n\n        for (i = 0, _length_i = geometry.faces.length; i < _length_i; i++) {\n            face = geometry.faces[i];\n            faceVertexUvs = geometry.faceVertexUvs[0][i];\n            polygon = new Polygon();\n\n            if (face instanceof THREE.Face3) {\n                vertex = geometry.vertices[face.a];\n                uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[0].x, faceVertexUvs[0].y) : null;\n                vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[0], uvs);\n                vertex.applyMatrix4(this.matrix);\n                polygon.vertices.push(vertex);\n\n                vertex = geometry.vertices[face.b];\n                uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[1].x, faceVertexUvs[1].y) : null;\n                vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[1], uvs);\n                vertex.applyMatrix4(this.matrix);\n                polygon.vertices.push(vertex);\n\n                vertex = geometry.vertices[face.c];\n                uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[2].x, faceVertexUvs[2].y) : null;\n                vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[2], uvs);\n                vertex.applyMatrix4(this.matrix);\n                polygon.vertices.push(vertex);\n            } else if (_typeof(THREE.Face4)) {\n                vertex = geometry.vertices[face.a];\n                uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[0].x, faceVertexUvs[0].y) : null;\n                vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[0], uvs);\n                vertex.applyMatrix4(this.matrix);\n                polygon.vertices.push(vertex);\n\n                vertex = geometry.vertices[face.b];\n                uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[1].x, faceVertexUvs[1].y) : null;\n                vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[1], uvs);\n                vertex.applyMatrix4(this.matrix);\n                polygon.vertices.push(vertex);\n\n                vertex = geometry.vertices[face.c];\n                uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[2].x, faceVertexUvs[2].y) : null;\n                vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[2], uvs);\n                vertex.applyMatrix4(this.matrix);\n                polygon.vertices.push(vertex);\n\n                vertex = geometry.vertices[face.d];\n                uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[3].x, faceVertexUvs[3].y) : null;\n                vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[3], uvs);\n                vertex.applyMatrix4(this.matrix);\n                polygon.vertices.push(vertex);\n            } else {\n                throw 'Invalid face type at index ' + i;\n            }\n\n            polygon.calculateProperties();\n            polygons.push(polygon);\n        }\n\n        this.tree = new Node(polygons);\n    }\n\n    _createClass(ThreeBSP, [{\n        key: 'subtract',\n        value: function subtract(other_tree) {\n            var a = this.tree.clone(),\n                b = other_tree.tree.clone();\n\n            a.invert();\n            a.clipTo(b);\n            b.clipTo(a);\n            b.invert();\n            b.clipTo(a);\n            b.invert();\n            a.build(b.allPolygons());\n            a.invert();\n            a = new ThreeBSP(a);\n            a.matrix = this.matrix;\n            return a;\n        }\n    }, {\n        key: 'union',\n        value: function union(other_tree) {\n            var a = this.tree.clone(),\n                b = other_tree.tree.clone();\n\n            a.clipTo(b);\n            b.clipTo(a);\n            b.invert();\n            b.clipTo(a);\n            b.invert();\n            a.build(b.allPolygons());\n            a = new ThreeBSP(a);\n            a.matrix = this.matrix;\n            return a;\n        }\n    }, {\n        key: 'intersect',\n        value: function intersect(other_tree) {\n            var a = this.tree.clone(),\n                b = other_tree.tree.clone();\n\n            a.invert();\n            b.clipTo(a);\n            b.invert();\n            a.clipTo(b);\n            b.clipTo(a);\n            a.build(b.allPolygons());\n            a.invert();\n            a = new ThreeBSP(a);\n            a.matrix = this.matrix;\n            return a;\n        }\n    }, {\n        key: 'toGeometry',\n        value: function toGeometry() {\n            var i,\n                j,\n                matrix = new THREE.Matrix4().getInverse(this.matrix),\n                geometry = new THREE.Geometry(),\n                polygons = this.tree.allPolygons(),\n                polygon_count = polygons.length,\n                polygon,\n                polygon_vertice_count,\n                vertice_dict = {},\n                vertex_idx_a,\n                vertex_idx_b,\n                vertex_idx_c,\n                vertex,\n                face,\n                verticeUvs;\n\n            for (i = 0; i < polygon_count; i++) {\n                polygon = polygons[i];\n                polygon_vertice_count = polygon.vertices.length;\n\n                for (j = 2; j < polygon_vertice_count; j++) {\n                    verticeUvs = [];\n\n                    vertex = polygon.vertices[0];\n                    verticeUvs.push(new THREE.Vector2(vertex.uv.x, vertex.uv.y));\n                    vertex = new THREE.Vector3(vertex.x, vertex.y, vertex.z);\n                    vertex.applyMatrix4(matrix);\n\n                    if (typeof vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] !== 'undefined') {\n                        vertex_idx_a = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z];\n                    } else {\n                        geometry.vertices.push(vertex);\n                        vertex_idx_a = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] = geometry.vertices.length - 1;\n                    }\n\n                    vertex = polygon.vertices[j - 1];\n                    verticeUvs.push(new THREE.Vector2(vertex.uv.x, vertex.uv.y));\n                    vertex = new THREE.Vector3(vertex.x, vertex.y, vertex.z);\n                    vertex.applyMatrix4(matrix);\n                    if (typeof vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] !== 'undefined') {\n                        vertex_idx_b = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z];\n                    } else {\n                        geometry.vertices.push(vertex);\n                        vertex_idx_b = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] = geometry.vertices.length - 1;\n                    }\n\n                    vertex = polygon.vertices[j];\n                    verticeUvs.push(new THREE.Vector2(vertex.uv.x, vertex.uv.y));\n                    vertex = new THREE.Vector3(vertex.x, vertex.y, vertex.z);\n                    vertex.applyMatrix4(matrix);\n                    if (typeof vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] !== 'undefined') {\n                        vertex_idx_c = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z];\n                    } else {\n                        geometry.vertices.push(vertex);\n                        vertex_idx_c = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] = geometry.vertices.length - 1;\n                    }\n\n                    face = new THREE.Face3(vertex_idx_a, vertex_idx_b, vertex_idx_c, new THREE.Vector3(polygon.normal.x, polygon.normal.y, polygon.normal.z));\n\n                    geometry.faces.push(face);\n                    geometry.faceVertexUvs[0].push(verticeUvs);\n                }\n            }\n            return geometry;\n        }\n    }, {\n        key: 'toMesh',\n        value: function toMesh(material) {\n            var geometry = this.toGeometry(),\n                mesh = new THREE.Mesh(geometry, material);\n\n            mesh.position.setFromMatrixPosition(this.matrix);\n            mesh.rotation.setFromRotationMatrix(this.matrix);\n\n            return mesh;\n        }\n    }]);\n\n    return ThreeBSP;\n}();\n\nexport default ThreeBSP;\n\nvar Polygon = function () {\n    function Polygon(vertices, normal, w) {\n        _classCallCheck(this, Polygon);\n\n        if (!(vertices instanceof Array)) {\n            vertices = [];\n        }\n\n        this.vertices = vertices;\n        if (vertices.length > 0) {\n            this.calculateProperties();\n        } else {\n            this.normal = this.w = undefined;\n        }\n    }\n\n    _createClass(Polygon, [{\n        key: 'calculateProperties',\n        value: function calculateProperties() {\n            var a = this.vertices[0],\n                b = this.vertices[1],\n                c = this.vertices[2];\n\n            this.normal = b.clone().subtract(a).cross(c.clone().subtract(a)).normalize();\n\n            this.w = this.normal.clone().dot(a);\n\n            return this;\n        }\n    }, {\n        key: 'clone',\n        value: function clone() {\n            var i,\n                vertice_count,\n                polygon = new Polygon();\n\n            for (i = 0, vertice_count = this.vertices.length; i < vertice_count; i++) {\n                polygon.vertices.push(this.vertices[i].clone());\n            }\n            polygon.calculateProperties();\n\n            return polygon;\n        }\n    }, {\n        key: 'flip',\n        value: function flip() {\n            var i,\n                vertices = [];\n\n            this.normal.multiplyScalar(-1);\n            this.w *= -1;\n\n            for (i = this.vertices.length - 1; i >= 0; i--) {\n                vertices.push(this.vertices[i]);\n            }\n            this.vertices = vertices;\n\n            return this;\n        }\n    }, {\n        key: 'classifyVertex',\n        value: function classifyVertex(vertex) {\n            var side_value = this.normal.dot(vertex) - this.w;\n\n            if (side_value < -EPSILON) {\n                return BACK;\n            } else if (side_value > EPSILON) {\n                return FRONT;\n            } else {\n                return COPLANAR;\n            }\n        }\n    }, {\n        key: 'classifySide',\n        value: function classifySide(polygon) {\n            var i,\n                vertex,\n                classification,\n                num_positive = 0,\n                num_negative = 0,\n                vertice_count = polygon.vertices.length;\n\n            for (i = 0; i < vertice_count; i++) {\n                vertex = polygon.vertices[i];\n                classification = this.classifyVertex(vertex);\n                if (classification === FRONT) {\n                    num_positive++;\n                } else if (classification === BACK) {\n                    num_negative++;\n                }\n            }\n\n            if (num_positive > 0 && num_negative === 0) {\n                return FRONT;\n            } else if (num_positive === 0 && num_negative > 0) {\n                return BACK;\n            } else if (num_positive === 0 && num_negative === 0) {\n                return COPLANAR;\n            } else {\n                return SPANNING;\n            }\n        }\n    }, {\n        key: 'splitPolygon',\n        value: function splitPolygon(polygon, coplanar_front, coplanar_back, front, back) {\n            var classification = this.classifySide(polygon);\n\n            if (classification === COPLANAR) {\n\n                (this.normal.dot(polygon.normal) > 0 ? coplanar_front : coplanar_back).push(polygon);\n            } else if (classification === FRONT) {\n\n                front.push(polygon);\n            } else if (classification === BACK) {\n\n                back.push(polygon);\n            } else {\n\n                var vertice_count,\n                    i,\n                    j,\n                    ti,\n                    tj,\n                    vi,\n                    vj,\n                    t,\n                    v,\n                    f = [],\n                    b = [];\n\n                for (i = 0, vertice_count = polygon.vertices.length; i < vertice_count; i++) {\n\n                    j = (i + 1) % vertice_count;\n                    vi = polygon.vertices[i];\n                    vj = polygon.vertices[j];\n                    ti = this.classifyVertex(vi);\n                    tj = this.classifyVertex(vj);\n\n                    if (ti != BACK) f.push(vi);\n                    if (ti != FRONT) b.push(vi);\n                    if ((ti | tj) === SPANNING) {\n                        t = (this.w - this.normal.dot(vi)) / this.normal.dot(vj.clone().subtract(vi));\n                        v = vi.interpolate(vj, t);\n                        f.push(v);\n                        b.push(v);\n                    }\n                }\n\n                if (f.length >= 3) front.push(new Polygon(f).calculateProperties());\n                if (b.length >= 3) back.push(new Polygon(b).calculateProperties());\n            }\n        }\n    }]);\n\n    return Polygon;\n}();\n\nvar Vertex = function () {\n    function Vertex(x, y, z, normal, uv) {\n        _classCallCheck(this, Vertex);\n\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.normal = normal || new THREE.Vector3();\n        this.uv = uv || new THREE.Vector2();\n    }\n\n    _createClass(Vertex, [{\n        key: 'clone',\n        value: function clone() {\n            return new Vertex(this.x, this.y, this.z, this.normal.clone(), this.uv.clone());\n        }\n    }, {\n        key: 'add',\n        value: function add(vertex) {\n            this.x += vertex.x;\n            this.y += vertex.y;\n            this.z += vertex.z;\n            return this;\n        }\n    }, {\n        key: 'subtract',\n        value: function subtract(vertex) {\n            this.x -= vertex.x;\n            this.y -= vertex.y;\n            this.z -= vertex.z;\n            return this;\n        }\n    }, {\n        key: 'multiplyScalar',\n        value: function multiplyScalar(scalar) {\n            this.x *= scalar;\n            this.y *= scalar;\n            this.z *= scalar;\n            return this;\n        }\n    }, {\n        key: 'cross',\n        value: function cross(vertex) {\n            var x = this.x,\n                y = this.y,\n                z = this.z;\n\n            this.x = y * vertex.z - z * vertex.y;\n            this.y = z * vertex.x - x * vertex.z;\n            this.z = x * vertex.y - y * vertex.x;\n\n            return this;\n        }\n    }, {\n        key: 'normalize',\n        value: function normalize() {\n            var length = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n\n            this.x /= length;\n            this.y /= length;\n            this.z /= length;\n\n            return this;\n        }\n    }, {\n        key: 'dot',\n        value: function dot(vertex) {\n            return this.x * vertex.x + this.y * vertex.y + this.z * vertex.z;\n        }\n    }, {\n        key: 'lerp',\n        value: function lerp(a, t) {\n            this.add(a.clone().subtract(this).multiplyScalar(t));\n\n            this.normal.add(a.normal.clone().sub(this.normal).multiplyScalar(t));\n\n            this.uv.add(a.uv.clone().sub(this.uv).multiplyScalar(t));\n\n            return this;\n        }\n    }, {\n        key: 'interpolate',\n        value: function interpolate(other, t) {\n            return this.clone().lerp(other, t);\n        }\n    }, {\n        key: 'applyMatrix4',\n        value: function applyMatrix4(m) {\n\n            // input: THREE.Matrix4 affine matrix\n\n            var x = this.x,\n                y = this.y,\n                z = this.z;\n\n            var e = m.elements;\n\n            this.x = e[0] * x + e[4] * y + e[8] * z + e[12];\n            this.y = e[1] * x + e[5] * y + e[9] * z + e[13];\n            this.z = e[2] * x + e[6] * y + e[10] * z + e[14];\n\n            return this;\n        }\n    }]);\n\n    return Vertex;\n}();\n\nvar Node = function () {\n    function Node(polygons) {\n        _classCallCheck(this, Node);\n\n        var i,\n            polygon_count,\n            front = [],\n            back = [];\n\n        this.polygons = [];\n        this.front = this.back = undefined;\n\n        if (!(polygons instanceof Array) || polygons.length === 0) return;\n\n        this.divider = polygons[0].clone();\n\n        for (i = 0, polygon_count = polygons.length; i < polygon_count; i++) {\n            this.divider.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\n        }\n\n        if (front.length > 0) {\n            this.front = new Node(front);\n        }\n\n        if (back.length > 0) {\n            this.back = new Node(back);\n        }\n    }\n\n    _createClass(Node, [{\n        key: 'isConvex',\n        value: function isConvex(polygons) {\n            var i, j;\n            for (i = 0; i < polygons.length; i++) {\n                for (j = 0; j < polygons.length; j++) {\n                    if (i !== j && polygons[i].classifySide(polygons[j]) !== BACK) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    }, {\n        key: 'build',\n        value: function build(polygons) {\n            var i,\n                polygon_count,\n                front = [],\n                back = [];\n\n            if (!this.divider) {\n                this.divider = polygons[0].clone();\n            }\n\n            for (i = 0, polygon_count = polygons.length; i < polygon_count; i++) {\n                this.divider.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\n            }\n\n            if (front.length > 0) {\n                if (!this.front) this.front = new Node();\n                this.front.build(front);\n            }\n\n            if (back.length > 0) {\n                if (!this.back) this.back = new Node();\n                this.back.build(back);\n            }\n        }\n    }, {\n        key: 'allPolygons',\n        value: function allPolygons() {\n            var polygons = this.polygons.slice();\n            if (this.front) polygons = polygons.concat(this.front.allPolygons());\n            if (this.back) polygons = polygons.concat(this.back.allPolygons());\n            return polygons;\n        }\n    }, {\n        key: 'clone',\n        value: function clone() {\n            var node = new Node();\n\n            node.divider = this.divider.clone();\n            node.polygons = this.polygons.map(function (polygon) {\n                return polygon.clone();\n            });\n            node.front = this.front && this.front.clone();\n            node.back = this.back && this.back.clone();\n\n            return node;\n        }\n    }, {\n        key: 'invert',\n        value: function invert() {\n            var i, polygon_count, temp;\n\n            for (i = 0, polygon_count = this.polygons.length; i < polygon_count; i++) {\n                this.polygons[i].flip();\n            }\n\n            this.divider.flip();\n            if (this.front) this.front.invert();\n            if (this.back) this.back.invert();\n\n            temp = this.front;\n            this.front = this.back;\n            this.back = temp;\n\n            return this;\n        }\n    }, {\n        key: 'clipPolygons',\n        value: function clipPolygons(polygons) {\n            var i, polygon_count, front, back;\n\n            if (!this.divider) return polygons.slice();\n\n            front = [];\n            back = [];\n\n            for (i = 0, polygon_count = polygons.length; i < polygon_count; i++) {\n                this.divider.splitPolygon(polygons[i], front, back, front, back);\n            }\n\n            if (this.front) front = this.front.clipPolygons(front);\n            if (this.back) back = this.back.clipPolygons(back);else back = [];\n\n            return front.concat(back);\n        }\n    }, {\n        key: 'clipTo',\n        value: function clipTo(node) {\n            this.polygons = node.clipPolygons(this.polygons);\n            if (this.front) this.front.clipTo(node);\n            if (this.back) this.back.clipTo(node);\n        }\n    }]);\n\n    return Node;\n}();\n\nwindow.ThreeBSP = ThreeBSP;"]},"metadata":{},"sourceType":"module"}