{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nimport { Map, List } from 'immutable';\nimport { Vertex as VertexModel } from '../models';\nimport { IDBroker, GeometryUtils, SnapSceneUtils, SnapUtils } from '../utils/export';\nimport { MODE_DRAGGING_VERTEX, MODE_IDLE } from '../constants';\nimport { Layer, Line, Group } from '../class/export';\n\nvar Vertex = function () {\n  function Vertex() {\n    _classCallCheck(this, Vertex);\n  }\n\n  _createClass(Vertex, null, [{\n    key: 'add',\n    value: function add(state, layerID, x, y, relatedPrototype, relatedID) {\n      var vertex = state.getIn(['scene', 'layers', layerID, 'vertices']).find(function (vertex) {\n        return GeometryUtils.samePoints(vertex, {\n          x: x,\n          y: y\n        });\n      });\n\n      if (vertex) {\n        vertex = vertex.update(relatedPrototype, function (related) {\n          return related.push(relatedID);\n        });\n      } else {\n        vertex = new VertexModel(_defineProperty({\n          id: IDBroker.acquireID(),\n          name: 'Vertex',\n          x: x,\n          y: y\n        }, relatedPrototype, new List([relatedID])));\n      }\n\n      state = state.setIn(['scene', 'layers', layerID, 'vertices', vertex.id], vertex);\n      return {\n        updatedState: state,\n        vertex: vertex\n      };\n    }\n  }, {\n    key: 'setAttributes',\n    value: function setAttributes(state, layerID, vertexID, vertexAttributes) {\n      state = state.mergeIn(['scene', 'layers', layerID, 'vertices', vertexID], vertexAttributes);\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'addElement',\n    value: function addElement(state, layerID, vertexID, elementPrototype, elementID) {\n      state = state.updateIn(['scene', 'layers', layerID, 'vertices', vertexID, elementPrototype], function (list) {\n        return list.push(elementID);\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'removeElement',\n    value: function removeElement(state, layerID, vertexID, elementPrototype, elementID) {\n      var elementIndex = state.getIn(['scene', 'layers', layerID, 'vertices', vertexID, elementPrototype]).findIndex(function (el) {\n        return el === elementID;\n      });\n\n      if (elementIndex !== -1) {\n        state = state.updateIn(['scene', 'layers', layerID, 'vertices', vertexID, elementPrototype], function (list) {\n          return list.remove(elementIndex);\n        });\n      }\n\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'select',\n    value: function select(state, layerID, vertexID) {\n      state = state.setIn(['scene', 'layers', layerID, 'vertices', vertexID, 'selected'], true);\n      state = state.updateIn(['scene', 'layers', layerID, 'selected', 'vertices'], function (elems) {\n        return elems.push(vertexID);\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'unselect',\n    value: function unselect(state, layerID, vertexID) {\n      state = state.setIn(['scene', 'layers', layerID, 'vertices', vertexID, 'selected'], false);\n      state = state.updateIn(['scene', 'layers', layerID, 'selected', 'vertices'], function (elems) {\n        return elems.filter(function (el) {\n          return el.id !== vertexID;\n        });\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'remove',\n    value: function remove(state, layerID, vertexID, relatedPrototype, relatedID, forceRemove) {\n      var vertex = state.getIn(['scene', 'layers', layerID, 'vertices', vertexID]);\n\n      if (vertex) {\n        if (relatedPrototype && relatedID) vertex = vertex.update(relatedPrototype, function (related) {\n          var index = related.findIndex(function (ID) {\n            return relatedID === ID;\n          });\n          return related.delete(index);\n        });\n        var inUse = vertex.areas.size || vertex.lines.size;\n\n        if (inUse && !forceRemove) {\n          state = state.setIn(['scene', 'layers', layerID, 'vertices', vertexID], vertex);\n        } else {\n          state = state.deleteIn(['scene', 'layers', layerID, 'vertices', vertexID]);\n        }\n      }\n\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'beginDraggingVertex',\n    value: function beginDraggingVertex(state, layerID, vertexID, x, y) {\n      var snapElements = SnapSceneUtils.sceneSnapElements(state.scene, new List(), state.snapMask);\n      state = state.merge({\n        mode: MODE_DRAGGING_VERTEX,\n        snapElements: snapElements,\n        draggingSupport: Map({\n          layerID: layerID,\n          vertexID: vertexID,\n          previousMode: state.get('mode')\n        })\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'updateDraggingVertex',\n    value: function updateDraggingVertex(state, x, y) {\n      var _state = state,\n          draggingSupport = _state.draggingSupport,\n          snapElements = _state.snapElements,\n          scene = _state.scene;\n      var snap = null;\n\n      if (state.snapMask && !state.snapMask.isEmpty()) {\n        snap = SnapUtils.nearestSnap(snapElements, x, y, state.snapMask);\n\n        if (snap) {\n          ;\n          var _snap$point = snap.point;\n          x = _snap$point.x;\n          y = _snap$point.y;\n        }\n      }\n\n      var layerID = draggingSupport.get('layerID');\n      var vertexID = draggingSupport.get('vertexID');\n      state = state.merge({\n        activeSnapElement: snap ? snap.snap : null,\n        scene: scene.mergeIn(['layers', layerID, 'vertices', vertexID], {\n          x: x,\n          y: y\n        })\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'endDraggingVertex',\n    value: function endDraggingVertex(state, x, y) {\n      var _state2 = state,\n          draggingSupport = _state2.draggingSupport;\n      var layerID = draggingSupport.get('layerID');\n      var vertexID = draggingSupport.get('vertexID');\n      var lines = state.getIn(['scene', 'layers', layerID, 'vertices', vertexID, 'lines']);\n\n      if (lines) {\n        state = lines.reduce(function (reducedState, lineID) {\n          if (!reducedState.getIn(['scene', 'layers', layerID, 'lines', lineID])) return reducedState;\n          var v_id0 = reducedState.getIn(['scene', 'layers', layerID, 'lines', lineID, 'vertices', 0]);\n          var v_id1 = reducedState.getIn(['scene', 'layers', layerID, 'lines', lineID, 'vertices', 1]);\n          var oldVertexID = v_id0 === vertexID ? v_id1 : v_id0;\n          var oldVertex = reducedState.getIn(['scene', 'layers', layerID, 'vertices', oldVertexID]);\n          var vertex = reducedState.getIn(['scene', 'layers', layerID, 'vertices', vertexID]);\n          var oldHoles = [];\n          var orderedVertices = GeometryUtils.orderVertices([oldVertex, vertex]);\n          var holes = reducedState.getIn(['scene', 'layers', layerID, 'lines', lineID, 'holes']).forEach(function (holeID) {\n            var hole = reducedState.getIn(['scene', 'layers', layerID, 'holes', holeID]);\n            var oldLineLength = GeometryUtils.pointsDistance(oldVertex.x, oldVertex.y, vertex.x, vertex.y);\n            var offset = GeometryUtils.samePoints(orderedVertices[1], reducedState.getIn(['scene', 'layers', layerID, 'lines', lineID, 'vertices', 1])) ? 1 - hole.offset : hole.offset;\n            var offsetPosition = GeometryUtils.extendLine(oldVertex.x, oldVertex.y, vertex.x, vertex.y, oldLineLength * offset);\n            oldHoles.push({\n              hole: hole,\n              offsetPosition: offsetPosition\n            });\n          });\n          var lineType = reducedState.getIn(['scene', 'layers', layerID, 'lines', lineID, 'type']);\n          var lineProps = reducedState.getIn(['scene', 'layers', layerID, 'lines', lineID, 'properties']);\n          var lineGroups = reducedState //get groups membership if present\n          .getIn(['scene', 'groups']).filter(function (group) {\n            var lines = group.getIn(['elements', layerID, 'lines']);\n            return lines && lines.contains(lineID);\n          });\n          reducedState = Layer.removeZeroLengthLines(reducedState, layerID).updatedState;\n          reducedState = Layer.mergeEqualsVertices(reducedState, layerID, vertexID).updatedState;\n          reducedState = Line.remove(reducedState, layerID, lineID).updatedState;\n\n          if (!GeometryUtils.samePoints(oldVertex, vertex)) {\n            var ret = Line.createAvoidingIntersections(reducedState, layerID, lineType, oldVertex.x, oldVertex.y, vertex.x, vertex.y, lineProps, oldHoles);\n            reducedState = ret.updatedState; //re-add to old line's groups if present\n\n            ret.lines.forEach(function (addedLine) {\n              lineGroups.forEach(function (oldLineGroup) {\n                reducedState = Group.addElement(reducedState, oldLineGroup.id, layerID, 'lines', addedLine.id).updatedState;\n              });\n            });\n          }\n\n          return reducedState;\n        }, state);\n      }\n\n      state = Layer.detectAndUpdateAreas(state, layerID).updatedState;\n      state = state.merge({\n        mode: draggingSupport.get('previousMode'),\n        draggingSupport: null,\n        activeSnapElement: null,\n        snapElements: new List()\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }]);\n\n  return Vertex;\n}();\n\nexport { Vertex as default };","map":{"version":3,"sources":["/home/srihari/Desktop/Sparkplug_PandemicSparks/grid/node_modules/react-planner/es/class/vertex.js"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_defineProperty","obj","value","_classCallCheck","instance","TypeError","Map","List","Vertex","VertexModel","IDBroker","GeometryUtils","SnapSceneUtils","SnapUtils","MODE_DRAGGING_VERTEX","MODE_IDLE","Layer","Line","Group","add","state","layerID","x","y","relatedPrototype","relatedID","vertex","getIn","find","samePoints","update","related","push","id","acquireID","name","setIn","updatedState","setAttributes","vertexID","vertexAttributes","mergeIn","addElement","elementPrototype","elementID","updateIn","list","removeElement","elementIndex","findIndex","el","remove","select","elems","unselect","filter","forceRemove","index","ID","delete","inUse","areas","size","lines","deleteIn","beginDraggingVertex","snapElements","sceneSnapElements","scene","snapMask","merge","mode","draggingSupport","previousMode","get","updateDraggingVertex","_state","snap","isEmpty","nearestSnap","_snap$point","point","activeSnapElement","endDraggingVertex","_state2","reduce","reducedState","lineID","v_id0","v_id1","oldVertexID","oldVertex","oldHoles","orderedVertices","orderVertices","holes","forEach","holeID","hole","oldLineLength","pointsDistance","offset","offsetPosition","extendLine","lineType","lineProps","lineGroups","group","contains","removeZeroLengthLines","mergeEqualsVertices","ret","createAvoidingIntersections","addedLine","oldLineGroup","detectAndUpdateAreas","default"],"mappings":"AAAA,IAAIA,YAAY,GAAG,YAAY;AAAE,WAASC,gBAAT,CAA0BC,MAA1B,EAAkCC,KAAlC,EAAyC;AAAE,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAAE,UAAIE,UAAU,GAAGH,KAAK,CAACC,CAAD,CAAtB;AAA2BE,MAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,MAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,UAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BC,MAAAA,MAAM,CAACC,cAAP,CAAsBT,MAAtB,EAA8BI,UAAU,CAACM,GAAzC,EAA8CN,UAA9C;AAA4D;AAAE;;AAAC,SAAO,UAAUO,WAAV,EAAuBC,UAAvB,EAAmCC,WAAnC,EAAgD;AAAE,QAAID,UAAJ,EAAgBb,gBAAgB,CAACY,WAAW,CAACG,SAAb,EAAwBF,UAAxB,CAAhB;AAAqD,QAAIC,WAAJ,EAAiBd,gBAAgB,CAACY,WAAD,EAAcE,WAAd,CAAhB;AAA4C,WAAOF,WAAP;AAAqB,GAAhN;AAAmN,CAA9hB,EAAnB;;AAEA,SAASI,eAAT,CAAyBC,GAAzB,EAA8BN,GAA9B,EAAmCO,KAAnC,EAA0C;AAAE,MAAIP,GAAG,IAAIM,GAAX,EAAgB;AAAER,IAAAA,MAAM,CAACC,cAAP,CAAsBO,GAAtB,EAA2BN,GAA3B,EAAgC;AAAEO,MAAAA,KAAK,EAAEA,KAAT;AAAgBZ,MAAAA,UAAU,EAAE,IAA5B;AAAkCC,MAAAA,YAAY,EAAE,IAAhD;AAAsDC,MAAAA,QAAQ,EAAE;AAAhE,KAAhC;AAA0G,GAA5H,MAAkI;AAAES,IAAAA,GAAG,CAACN,GAAD,CAAH,GAAWO,KAAX;AAAmB;;AAAC,SAAOD,GAAP;AAAa;;AAEjN,SAASE,eAAT,CAAyBC,QAAzB,EAAmCR,WAAnC,EAAgD;AAAE,MAAI,EAAEQ,QAAQ,YAAYR,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIS,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,SAASC,GAAT,EAAcC,IAAd,QAA0B,WAA1B;AACA,SAASC,MAAM,IAAIC,WAAnB,QAAsC,WAAtC;AACA,SAASC,QAAT,EAAmBC,aAAnB,EAAkCC,cAAlC,EAAkDC,SAAlD,QAAmE,iBAAnE;AACA,SAASC,oBAAT,EAA+BC,SAA/B,QAAgD,cAAhD;AACA,SAASC,KAAT,EAAgBC,IAAhB,EAAsBC,KAAtB,QAAmC,iBAAnC;;AAEA,IAAIV,MAAM,GAAG,YAAY;AACvB,WAASA,MAAT,GAAkB;AAChBL,IAAAA,eAAe,CAAC,IAAD,EAAOK,MAAP,CAAf;AACD;;AAEDzB,EAAAA,YAAY,CAACyB,MAAD,EAAS,IAAT,EAAe,CAAC;AAC1Bb,IAAAA,GAAG,EAAE,KADqB;AAE1BO,IAAAA,KAAK,EAAE,SAASiB,GAAT,CAAaC,KAAb,EAAoBC,OAApB,EAA6BC,CAA7B,EAAgCC,CAAhC,EAAmCC,gBAAnC,EAAqDC,SAArD,EAAgE;AAErE,UAAIC,MAAM,GAAGN,KAAK,CAACO,KAAN,CAAY,CAAC,OAAD,EAAU,QAAV,EAAoBN,OAApB,EAA6B,UAA7B,CAAZ,EAAsDO,IAAtD,CAA2D,UAAUF,MAAV,EAAkB;AACxF,eAAOf,aAAa,CAACkB,UAAd,CAAyBH,MAAzB,EAAiC;AAAEJ,UAAAA,CAAC,EAAEA,CAAL;AAAQC,UAAAA,CAAC,EAAEA;AAAX,SAAjC,CAAP;AACD,OAFY,CAAb;;AAIA,UAAIG,MAAJ,EAAY;AACVA,QAAAA,MAAM,GAAGA,MAAM,CAACI,MAAP,CAAcN,gBAAd,EAAgC,UAAUO,OAAV,EAAmB;AAC1D,iBAAOA,OAAO,CAACC,IAAR,CAAaP,SAAb,CAAP;AACD,SAFQ,CAAT;AAGD,OAJD,MAIO;AACLC,QAAAA,MAAM,GAAG,IAAIjB,WAAJ,CAAgBT,eAAe,CAAC;AACvCiC,UAAAA,EAAE,EAAEvB,QAAQ,CAACwB,SAAT,EADmC;AAEvCC,UAAAA,IAAI,EAAE,QAFiC;AAGvCb,UAAAA,CAAC,EAAEA,CAHoC;AAGjCC,UAAAA,CAAC,EAAEA;AAH8B,SAAD,EAIrCC,gBAJqC,EAInB,IAAIjB,IAAJ,CAAS,CAACkB,SAAD,CAAT,CAJmB,CAA/B,CAAT;AAKD;;AAEDL,MAAAA,KAAK,GAAGA,KAAK,CAACgB,KAAN,CAAY,CAAC,OAAD,EAAU,QAAV,EAAoBf,OAApB,EAA6B,UAA7B,EAAyCK,MAAM,CAACO,EAAhD,CAAZ,EAAiEP,MAAjE,CAAR;AAEA,aAAO;AAAEW,QAAAA,YAAY,EAAEjB,KAAhB;AAAuBM,QAAAA,MAAM,EAAEA;AAA/B,OAAP;AACD;AAvByB,GAAD,EAwBxB;AACD/B,IAAAA,GAAG,EAAE,eADJ;AAEDO,IAAAA,KAAK,EAAE,SAASoC,aAAT,CAAuBlB,KAAvB,EAA8BC,OAA9B,EAAuCkB,QAAvC,EAAiDC,gBAAjD,EAAmE;AACxEpB,MAAAA,KAAK,GAAGA,KAAK,CAACqB,OAAN,CAAc,CAAC,OAAD,EAAU,QAAV,EAAoBpB,OAApB,EAA6B,UAA7B,EAAyCkB,QAAzC,CAAd,EAAkEC,gBAAlE,CAAR;AAEA,aAAO;AAAEH,QAAAA,YAAY,EAAEjB;AAAhB,OAAP;AACD;AANA,GAxBwB,EA+BxB;AACDzB,IAAAA,GAAG,EAAE,YADJ;AAEDO,IAAAA,KAAK,EAAE,SAASwC,UAAT,CAAoBtB,KAApB,EAA2BC,OAA3B,EAAoCkB,QAApC,EAA8CI,gBAA9C,EAAgEC,SAAhE,EAA2E;AAChFxB,MAAAA,KAAK,GAAGA,KAAK,CAACyB,QAAN,CAAe,CAAC,OAAD,EAAU,QAAV,EAAoBxB,OAApB,EAA6B,UAA7B,EAAyCkB,QAAzC,EAAmDI,gBAAnD,CAAf,EAAqF,UAAUG,IAAV,EAAgB;AAC3G,eAAOA,IAAI,CAACd,IAAL,CAAUY,SAAV,CAAP;AACD,OAFO,CAAR;AAGA,aAAO;AAAEP,QAAAA,YAAY,EAAEjB;AAAhB,OAAP;AACD;AAPA,GA/BwB,EAuCxB;AACDzB,IAAAA,GAAG,EAAE,eADJ;AAEDO,IAAAA,KAAK,EAAE,SAAS6C,aAAT,CAAuB3B,KAAvB,EAA8BC,OAA9B,EAAuCkB,QAAvC,EAAiDI,gBAAjD,EAAmEC,SAAnE,EAA8E;AACnF,UAAII,YAAY,GAAG5B,KAAK,CAACO,KAAN,CAAY,CAAC,OAAD,EAAU,QAAV,EAAoBN,OAApB,EAA6B,UAA7B,EAAyCkB,QAAzC,EAAmDI,gBAAnD,CAAZ,EAAkFM,SAAlF,CAA4F,UAAUC,EAAV,EAAc;AAC3H,eAAOA,EAAE,KAAKN,SAAd;AACD,OAFkB,CAAnB;;AAGA,UAAII,YAAY,KAAK,CAAC,CAAtB,EAAyB;AACvB5B,QAAAA,KAAK,GAAGA,KAAK,CAACyB,QAAN,CAAe,CAAC,OAAD,EAAU,QAAV,EAAoBxB,OAApB,EAA6B,UAA7B,EAAyCkB,QAAzC,EAAmDI,gBAAnD,CAAf,EAAqF,UAAUG,IAAV,EAAgB;AAC3G,iBAAOA,IAAI,CAACK,MAAL,CAAYH,YAAZ,CAAP;AACD,SAFO,CAAR;AAGD;;AACD,aAAO;AAAEX,QAAAA,YAAY,EAAEjB;AAAhB,OAAP;AACD;AAZA,GAvCwB,EAoDxB;AACDzB,IAAAA,GAAG,EAAE,QADJ;AAEDO,IAAAA,KAAK,EAAE,SAASkD,MAAT,CAAgBhC,KAAhB,EAAuBC,OAAvB,EAAgCkB,QAAhC,EAA0C;AAC/CnB,MAAAA,KAAK,GAAGA,KAAK,CAACgB,KAAN,CAAY,CAAC,OAAD,EAAU,QAAV,EAAoBf,OAApB,EAA6B,UAA7B,EAAyCkB,QAAzC,EAAmD,UAAnD,CAAZ,EAA4E,IAA5E,CAAR;AACAnB,MAAAA,KAAK,GAAGA,KAAK,CAACyB,QAAN,CAAe,CAAC,OAAD,EAAU,QAAV,EAAoBxB,OAApB,EAA6B,UAA7B,EAAyC,UAAzC,CAAf,EAAqE,UAAUgC,KAAV,EAAiB;AAC5F,eAAOA,KAAK,CAACrB,IAAN,CAAWO,QAAX,CAAP;AACD,OAFO,CAAR;AAIA,aAAO;AAAEF,QAAAA,YAAY,EAAEjB;AAAhB,OAAP;AACD;AATA,GApDwB,EA8DxB;AACDzB,IAAAA,GAAG,EAAE,UADJ;AAEDO,IAAAA,KAAK,EAAE,SAASoD,QAAT,CAAkBlC,KAAlB,EAAyBC,OAAzB,EAAkCkB,QAAlC,EAA4C;AACjDnB,MAAAA,KAAK,GAAGA,KAAK,CAACgB,KAAN,CAAY,CAAC,OAAD,EAAU,QAAV,EAAoBf,OAApB,EAA6B,UAA7B,EAAyCkB,QAAzC,EAAmD,UAAnD,CAAZ,EAA4E,KAA5E,CAAR;AACAnB,MAAAA,KAAK,GAAGA,KAAK,CAACyB,QAAN,CAAe,CAAC,OAAD,EAAU,QAAV,EAAoBxB,OAApB,EAA6B,UAA7B,EAAyC,UAAzC,CAAf,EAAqE,UAAUgC,KAAV,EAAiB;AAC5F,eAAOA,KAAK,CAACE,MAAN,CAAa,UAAUL,EAAV,EAAc;AAChC,iBAAOA,EAAE,CAACjB,EAAH,KAAUM,QAAjB;AACD,SAFM,CAAP;AAGD,OAJO,CAAR;AAMA,aAAO;AAAEF,QAAAA,YAAY,EAAEjB;AAAhB,OAAP;AACD;AAXA,GA9DwB,EA0ExB;AACDzB,IAAAA,GAAG,EAAE,QADJ;AAEDO,IAAAA,KAAK,EAAE,SAASiD,MAAT,CAAgB/B,KAAhB,EAAuBC,OAAvB,EAAgCkB,QAAhC,EAA0Cf,gBAA1C,EAA4DC,SAA5D,EAAuE+B,WAAvE,EAAoF;AACzF,UAAI9B,MAAM,GAAGN,KAAK,CAACO,KAAN,CAAY,CAAC,OAAD,EAAU,QAAV,EAAoBN,OAApB,EAA6B,UAA7B,EAAyCkB,QAAzC,CAAZ,CAAb;;AAEA,UAAIb,MAAJ,EAAY;AACV,YAAIF,gBAAgB,IAAIC,SAAxB,EAAmCC,MAAM,GAAGA,MAAM,CAACI,MAAP,CAAcN,gBAAd,EAAgC,UAAUO,OAAV,EAAmB;AAC7F,cAAI0B,KAAK,GAAG1B,OAAO,CAACkB,SAAR,CAAkB,UAAUS,EAAV,EAAc;AAC1C,mBAAOjC,SAAS,KAAKiC,EAArB;AACD,WAFW,CAAZ;AAGA,iBAAO3B,OAAO,CAAC4B,MAAR,CAAeF,KAAf,CAAP;AACD,SAL2C,CAAT;AAOnC,YAAIG,KAAK,GAAGlC,MAAM,CAACmC,KAAP,CAAaC,IAAb,IAAqBpC,MAAM,CAACqC,KAAP,CAAaD,IAA9C;;AAEA,YAAIF,KAAK,IAAI,CAACJ,WAAd,EAA2B;AACzBpC,UAAAA,KAAK,GAAGA,KAAK,CAACgB,KAAN,CAAY,CAAC,OAAD,EAAU,QAAV,EAAoBf,OAApB,EAA6B,UAA7B,EAAyCkB,QAAzC,CAAZ,EAAgEb,MAAhE,CAAR;AACD,SAFD,MAEO;AACLN,UAAAA,KAAK,GAAGA,KAAK,CAAC4C,QAAN,CAAe,CAAC,OAAD,EAAU,QAAV,EAAoB3C,OAApB,EAA6B,UAA7B,EAAyCkB,QAAzC,CAAf,CAAR;AACD;AACF;;AAED,aAAO;AAAEF,QAAAA,YAAY,EAAEjB;AAAhB,OAAP;AACD;AAvBA,GA1EwB,EAkGxB;AACDzB,IAAAA,GAAG,EAAE,qBADJ;AAEDO,IAAAA,KAAK,EAAE,SAAS+D,mBAAT,CAA6B7C,KAA7B,EAAoCC,OAApC,EAA6CkB,QAA7C,EAAuDjB,CAAvD,EAA0DC,CAA1D,EAA6D;AAElE,UAAI2C,YAAY,GAAGtD,cAAc,CAACuD,iBAAf,CAAiC/C,KAAK,CAACgD,KAAvC,EAA8C,IAAI7D,IAAJ,EAA9C,EAA0Da,KAAK,CAACiD,QAAhE,CAAnB;AAEAjD,MAAAA,KAAK,GAAGA,KAAK,CAACkD,KAAN,CAAY;AAClBC,QAAAA,IAAI,EAAEzD,oBADY;AAElBoD,QAAAA,YAAY,EAAEA,YAFI;AAGlBM,QAAAA,eAAe,EAAElE,GAAG,CAAC;AACnBe,UAAAA,OAAO,EAAEA,OADU;AAEnBkB,UAAAA,QAAQ,EAAEA,QAFS;AAGnBkC,UAAAA,YAAY,EAAErD,KAAK,CAACsD,GAAN,CAAU,MAAV;AAHK,SAAD;AAHF,OAAZ,CAAR;AAUA,aAAO;AAAErC,QAAAA,YAAY,EAAEjB;AAAhB,OAAP;AACD;AAjBA,GAlGwB,EAoHxB;AACDzB,IAAAA,GAAG,EAAE,sBADJ;AAEDO,IAAAA,KAAK,EAAE,SAASyE,oBAAT,CAA8BvD,KAA9B,EAAqCE,CAArC,EAAwCC,CAAxC,EAA2C;AAChD,UAAIqD,MAAM,GAAGxD,KAAb;AAAA,UACIoD,eAAe,GAAGI,MAAM,CAACJ,eAD7B;AAAA,UAEIN,YAAY,GAAGU,MAAM,CAACV,YAF1B;AAAA,UAGIE,KAAK,GAAGQ,MAAM,CAACR,KAHnB;AAMA,UAAIS,IAAI,GAAG,IAAX;;AACA,UAAIzD,KAAK,CAACiD,QAAN,IAAkB,CAACjD,KAAK,CAACiD,QAAN,CAAeS,OAAf,EAAvB,EAAiD;AAC/CD,QAAAA,IAAI,GAAGhE,SAAS,CAACkE,WAAV,CAAsBb,YAAtB,EAAoC5C,CAApC,EAAuCC,CAAvC,EAA0CH,KAAK,CAACiD,QAAhD,CAAP;;AACA,YAAIQ,IAAJ,EAAU;AACR;AACA,cAAIG,WAAW,GAAGH,IAAI,CAACI,KAAvB;AACA3D,UAAAA,CAAC,GAAG0D,WAAW,CAAC1D,CAAhB;AACAC,UAAAA,CAAC,GAAGyD,WAAW,CAACzD,CAAhB;AACD;AACF;;AAED,UAAIF,OAAO,GAAGmD,eAAe,CAACE,GAAhB,CAAoB,SAApB,CAAd;AACA,UAAInC,QAAQ,GAAGiC,eAAe,CAACE,GAAhB,CAAoB,UAApB,CAAf;AACAtD,MAAAA,KAAK,GAAGA,KAAK,CAACkD,KAAN,CAAY;AAClBY,QAAAA,iBAAiB,EAAEL,IAAI,GAAGA,IAAI,CAACA,IAAR,GAAe,IADpB;AAElBT,QAAAA,KAAK,EAAEA,KAAK,CAAC3B,OAAN,CAAc,CAAC,QAAD,EAAWpB,OAAX,EAAoB,UAApB,EAAgCkB,QAAhC,CAAd,EAAyD;AAAEjB,UAAAA,CAAC,EAAEA,CAAL;AAAQC,UAAAA,CAAC,EAAEA;AAAX,SAAzD;AAFW,OAAZ,CAAR;AAKA,aAAO;AAAEc,QAAAA,YAAY,EAAEjB;AAAhB,OAAP;AACD;AA5BA,GApHwB,EAiJxB;AACDzB,IAAAA,GAAG,EAAE,mBADJ;AAEDO,IAAAA,KAAK,EAAE,SAASiF,iBAAT,CAA2B/D,KAA3B,EAAkCE,CAAlC,EAAqCC,CAArC,EAAwC;AAC7C,UAAI6D,OAAO,GAAGhE,KAAd;AAAA,UACIoD,eAAe,GAAGY,OAAO,CAACZ,eAD9B;AAGA,UAAInD,OAAO,GAAGmD,eAAe,CAACE,GAAhB,CAAoB,SAApB,CAAd;AACA,UAAInC,QAAQ,GAAGiC,eAAe,CAACE,GAAhB,CAAoB,UAApB,CAAf;AACA,UAAIX,KAAK,GAAG3C,KAAK,CAACO,KAAN,CAAY,CAAC,OAAD,EAAU,QAAV,EAAoBN,OAApB,EAA6B,UAA7B,EAAyCkB,QAAzC,EAAmD,OAAnD,CAAZ,CAAZ;;AAEA,UAAIwB,KAAJ,EAAW;AACT3C,QAAAA,KAAK,GAAG2C,KAAK,CAACsB,MAAN,CAAa,UAAUC,YAAV,EAAwBC,MAAxB,EAAgC;AACnD,cAAI,CAACD,YAAY,CAAC3D,KAAb,CAAmB,CAAC,OAAD,EAAU,QAAV,EAAoBN,OAApB,EAA6B,OAA7B,EAAsCkE,MAAtC,CAAnB,CAAL,EAAwE,OAAOD,YAAP;AAExE,cAAIE,KAAK,GAAGF,YAAY,CAAC3D,KAAb,CAAmB,CAAC,OAAD,EAAU,QAAV,EAAoBN,OAApB,EAA6B,OAA7B,EAAsCkE,MAAtC,EAA8C,UAA9C,EAA0D,CAA1D,CAAnB,CAAZ;AACA,cAAIE,KAAK,GAAGH,YAAY,CAAC3D,KAAb,CAAmB,CAAC,OAAD,EAAU,QAAV,EAAoBN,OAApB,EAA6B,OAA7B,EAAsCkE,MAAtC,EAA8C,UAA9C,EAA0D,CAA1D,CAAnB,CAAZ;AACA,cAAIG,WAAW,GAAGF,KAAK,KAAKjD,QAAV,GAAqBkD,KAArB,GAA6BD,KAA/C;AAEA,cAAIG,SAAS,GAAGL,YAAY,CAAC3D,KAAb,CAAmB,CAAC,OAAD,EAAU,QAAV,EAAoBN,OAApB,EAA6B,UAA7B,EAAyCqE,WAAzC,CAAnB,CAAhB;AACA,cAAIhE,MAAM,GAAG4D,YAAY,CAAC3D,KAAb,CAAmB,CAAC,OAAD,EAAU,QAAV,EAAoBN,OAApB,EAA6B,UAA7B,EAAyCkB,QAAzC,CAAnB,CAAb;AAEA,cAAIqD,QAAQ,GAAG,EAAf;AAEA,cAAIC,eAAe,GAAGlF,aAAa,CAACmF,aAAd,CAA4B,CAACH,SAAD,EAAYjE,MAAZ,CAA5B,CAAtB;AAEA,cAAIqE,KAAK,GAAGT,YAAY,CAAC3D,KAAb,CAAmB,CAAC,OAAD,EAAU,QAAV,EAAoBN,OAApB,EAA6B,OAA7B,EAAsCkE,MAAtC,EAA8C,OAA9C,CAAnB,EAA2ES,OAA3E,CAAmF,UAAUC,MAAV,EAAkB;AAC/G,gBAAIC,IAAI,GAAGZ,YAAY,CAAC3D,KAAb,CAAmB,CAAC,OAAD,EAAU,QAAV,EAAoBN,OAApB,EAA6B,OAA7B,EAAsC4E,MAAtC,CAAnB,CAAX;AACA,gBAAIE,aAAa,GAAGxF,aAAa,CAACyF,cAAd,CAA6BT,SAAS,CAACrE,CAAvC,EAA0CqE,SAAS,CAACpE,CAApD,EAAuDG,MAAM,CAACJ,CAA9D,EAAiEI,MAAM,CAACH,CAAxE,CAApB;AACA,gBAAI8E,MAAM,GAAG1F,aAAa,CAACkB,UAAd,CAAyBgE,eAAe,CAAC,CAAD,CAAxC,EAA6CP,YAAY,CAAC3D,KAAb,CAAmB,CAAC,OAAD,EAAU,QAAV,EAAoBN,OAApB,EAA6B,OAA7B,EAAsCkE,MAAtC,EAA8C,UAA9C,EAA0D,CAA1D,CAAnB,CAA7C,IAAiI,IAAIW,IAAI,CAACG,MAA1I,GAAmJH,IAAI,CAACG,MAArK;AACA,gBAAIC,cAAc,GAAG3F,aAAa,CAAC4F,UAAd,CAAyBZ,SAAS,CAACrE,CAAnC,EAAsCqE,SAAS,CAACpE,CAAhD,EAAmDG,MAAM,CAACJ,CAA1D,EAA6DI,MAAM,CAACH,CAApE,EAAuE4E,aAAa,GAAGE,MAAvF,CAArB;AAEAT,YAAAA,QAAQ,CAAC5D,IAAT,CAAc;AAAEkE,cAAAA,IAAI,EAAEA,IAAR;AAAcI,cAAAA,cAAc,EAAEA;AAA9B,aAAd;AACD,WAPW,CAAZ;AASA,cAAIE,QAAQ,GAAGlB,YAAY,CAAC3D,KAAb,CAAmB,CAAC,OAAD,EAAU,QAAV,EAAoBN,OAApB,EAA6B,OAA7B,EAAsCkE,MAAtC,EAA8C,MAA9C,CAAnB,CAAf;AACA,cAAIkB,SAAS,GAAGnB,YAAY,CAAC3D,KAAb,CAAmB,CAAC,OAAD,EAAU,QAAV,EAAoBN,OAApB,EAA6B,OAA7B,EAAsCkE,MAAtC,EAA8C,YAA9C,CAAnB,CAAhB;AACA,cAAImB,UAAU,GAAGpB,YAAY,CAAC;AAAD,WAC5B3D,KADgB,CACV,CAAC,OAAD,EAAU,QAAV,CADU,EACW4B,MADX,CACkB,UAAUoD,KAAV,EAAiB;AAClD,gBAAI5C,KAAK,GAAG4C,KAAK,CAAChF,KAAN,CAAY,CAAC,UAAD,EAAaN,OAAb,EAAsB,OAAtB,CAAZ,CAAZ;AACA,mBAAO0C,KAAK,IAAIA,KAAK,CAAC6C,QAAN,CAAerB,MAAf,CAAhB;AACD,WAJgB,CAAjB;AAMAD,UAAAA,YAAY,GAAGtE,KAAK,CAAC6F,qBAAN,CAA4BvB,YAA5B,EAA0CjE,OAA1C,EAAmDgB,YAAlE;AACAiD,UAAAA,YAAY,GAAGtE,KAAK,CAAC8F,mBAAN,CAA0BxB,YAA1B,EAAwCjE,OAAxC,EAAiDkB,QAAjD,EAA2DF,YAA1E;AACAiD,UAAAA,YAAY,GAAGrE,IAAI,CAACkC,MAAL,CAAYmC,YAAZ,EAA0BjE,OAA1B,EAAmCkE,MAAnC,EAA2ClD,YAA1D;;AAEA,cAAI,CAAC1B,aAAa,CAACkB,UAAd,CAAyB8D,SAAzB,EAAoCjE,MAApC,CAAL,EAAkD;AAChD,gBAAIqF,GAAG,GAAG9F,IAAI,CAAC+F,2BAAL,CAAiC1B,YAAjC,EAA+CjE,OAA/C,EAAwDmF,QAAxD,EAAkEb,SAAS,CAACrE,CAA5E,EAA+EqE,SAAS,CAACpE,CAAzF,EAA4FG,MAAM,CAACJ,CAAnG,EAAsGI,MAAM,CAACH,CAA7G,EAAgHkF,SAAhH,EAA2Hb,QAA3H,CAAV;AAEAN,YAAAA,YAAY,GAAGyB,GAAG,CAAC1E,YAAnB,CAHgD,CAKhD;;AACA0E,YAAAA,GAAG,CAAChD,KAAJ,CAAUiC,OAAV,CAAkB,UAAUiB,SAAV,EAAqB;AACrCP,cAAAA,UAAU,CAACV,OAAX,CAAmB,UAAUkB,YAAV,EAAwB;AACzC5B,gBAAAA,YAAY,GAAGpE,KAAK,CAACwB,UAAN,CAAiB4C,YAAjB,EAA+B4B,YAAY,CAACjF,EAA5C,EAAgDZ,OAAhD,EAAyD,OAAzD,EAAkE4F,SAAS,CAAChF,EAA5E,EAAgFI,YAA/F;AACD,eAFD;AAGD,aAJD;AAKD;;AAED,iBAAOiD,YAAP;AACD,SAjDO,EAiDLlE,KAjDK,CAAR;AAkDD;;AAEDA,MAAAA,KAAK,GAAGJ,KAAK,CAACmG,oBAAN,CAA2B/F,KAA3B,EAAkCC,OAAlC,EAA2CgB,YAAnD;AAEAjB,MAAAA,KAAK,GAAGA,KAAK,CAACkD,KAAN,CAAY;AAClBC,QAAAA,IAAI,EAAEC,eAAe,CAACE,GAAhB,CAAoB,cAApB,CADY;AAElBF,QAAAA,eAAe,EAAE,IAFC;AAGlBU,QAAAA,iBAAiB,EAAE,IAHD;AAIlBhB,QAAAA,YAAY,EAAE,IAAI3D,IAAJ;AAJI,OAAZ,CAAR;AAOA,aAAO;AAAE8B,QAAAA,YAAY,EAAEjB;AAAhB,OAAP;AACD;AAzEA,GAjJwB,CAAf,CAAZ;;AA6NA,SAAOZ,MAAP;AACD,CAnOY,EAAb;;AAqOA,SAASA,MAAM,IAAI4G,OAAnB","sourcesContent":["var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nimport { Map, List } from 'immutable';\nimport { Vertex as VertexModel } from '../models';\nimport { IDBroker, GeometryUtils, SnapSceneUtils, SnapUtils } from '../utils/export';\nimport { MODE_DRAGGING_VERTEX, MODE_IDLE } from '../constants';\nimport { Layer, Line, Group } from '../class/export';\n\nvar Vertex = function () {\n  function Vertex() {\n    _classCallCheck(this, Vertex);\n  }\n\n  _createClass(Vertex, null, [{\n    key: 'add',\n    value: function add(state, layerID, x, y, relatedPrototype, relatedID) {\n\n      var vertex = state.getIn(['scene', 'layers', layerID, 'vertices']).find(function (vertex) {\n        return GeometryUtils.samePoints(vertex, { x: x, y: y });\n      });\n\n      if (vertex) {\n        vertex = vertex.update(relatedPrototype, function (related) {\n          return related.push(relatedID);\n        });\n      } else {\n        vertex = new VertexModel(_defineProperty({\n          id: IDBroker.acquireID(),\n          name: 'Vertex',\n          x: x, y: y\n        }, relatedPrototype, new List([relatedID])));\n      }\n\n      state = state.setIn(['scene', 'layers', layerID, 'vertices', vertex.id], vertex);\n\n      return { updatedState: state, vertex: vertex };\n    }\n  }, {\n    key: 'setAttributes',\n    value: function setAttributes(state, layerID, vertexID, vertexAttributes) {\n      state = state.mergeIn(['scene', 'layers', layerID, 'vertices', vertexID], vertexAttributes);\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'addElement',\n    value: function addElement(state, layerID, vertexID, elementPrototype, elementID) {\n      state = state.updateIn(['scene', 'layers', layerID, 'vertices', vertexID, elementPrototype], function (list) {\n        return list.push(elementID);\n      });\n      return { updatedState: state };\n    }\n  }, {\n    key: 'removeElement',\n    value: function removeElement(state, layerID, vertexID, elementPrototype, elementID) {\n      var elementIndex = state.getIn(['scene', 'layers', layerID, 'vertices', vertexID, elementPrototype]).findIndex(function (el) {\n        return el === elementID;\n      });\n      if (elementIndex !== -1) {\n        state = state.updateIn(['scene', 'layers', layerID, 'vertices', vertexID, elementPrototype], function (list) {\n          return list.remove(elementIndex);\n        });\n      }\n      return { updatedState: state };\n    }\n  }, {\n    key: 'select',\n    value: function select(state, layerID, vertexID) {\n      state = state.setIn(['scene', 'layers', layerID, 'vertices', vertexID, 'selected'], true);\n      state = state.updateIn(['scene', 'layers', layerID, 'selected', 'vertices'], function (elems) {\n        return elems.push(vertexID);\n      });\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'unselect',\n    value: function unselect(state, layerID, vertexID) {\n      state = state.setIn(['scene', 'layers', layerID, 'vertices', vertexID, 'selected'], false);\n      state = state.updateIn(['scene', 'layers', layerID, 'selected', 'vertices'], function (elems) {\n        return elems.filter(function (el) {\n          return el.id !== vertexID;\n        });\n      });\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'remove',\n    value: function remove(state, layerID, vertexID, relatedPrototype, relatedID, forceRemove) {\n      var vertex = state.getIn(['scene', 'layers', layerID, 'vertices', vertexID]);\n\n      if (vertex) {\n        if (relatedPrototype && relatedID) vertex = vertex.update(relatedPrototype, function (related) {\n          var index = related.findIndex(function (ID) {\n            return relatedID === ID;\n          });\n          return related.delete(index);\n        });\n\n        var inUse = vertex.areas.size || vertex.lines.size;\n\n        if (inUse && !forceRemove) {\n          state = state.setIn(['scene', 'layers', layerID, 'vertices', vertexID], vertex);\n        } else {\n          state = state.deleteIn(['scene', 'layers', layerID, 'vertices', vertexID]);\n        }\n      }\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'beginDraggingVertex',\n    value: function beginDraggingVertex(state, layerID, vertexID, x, y) {\n\n      var snapElements = SnapSceneUtils.sceneSnapElements(state.scene, new List(), state.snapMask);\n\n      state = state.merge({\n        mode: MODE_DRAGGING_VERTEX,\n        snapElements: snapElements,\n        draggingSupport: Map({\n          layerID: layerID,\n          vertexID: vertexID,\n          previousMode: state.get('mode')\n        })\n      });\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'updateDraggingVertex',\n    value: function updateDraggingVertex(state, x, y) {\n      var _state = state,\n          draggingSupport = _state.draggingSupport,\n          snapElements = _state.snapElements,\n          scene = _state.scene;\n\n\n      var snap = null;\n      if (state.snapMask && !state.snapMask.isEmpty()) {\n        snap = SnapUtils.nearestSnap(snapElements, x, y, state.snapMask);\n        if (snap) {\n          ;\n          var _snap$point = snap.point;\n          x = _snap$point.x;\n          y = _snap$point.y;\n        }\n      }\n\n      var layerID = draggingSupport.get('layerID');\n      var vertexID = draggingSupport.get('vertexID');\n      state = state.merge({\n        activeSnapElement: snap ? snap.snap : null,\n        scene: scene.mergeIn(['layers', layerID, 'vertices', vertexID], { x: x, y: y })\n      });\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'endDraggingVertex',\n    value: function endDraggingVertex(state, x, y) {\n      var _state2 = state,\n          draggingSupport = _state2.draggingSupport;\n\n      var layerID = draggingSupport.get('layerID');\n      var vertexID = draggingSupport.get('vertexID');\n      var lines = state.getIn(['scene', 'layers', layerID, 'vertices', vertexID, 'lines']);\n\n      if (lines) {\n        state = lines.reduce(function (reducedState, lineID) {\n          if (!reducedState.getIn(['scene', 'layers', layerID, 'lines', lineID])) return reducedState;\n\n          var v_id0 = reducedState.getIn(['scene', 'layers', layerID, 'lines', lineID, 'vertices', 0]);\n          var v_id1 = reducedState.getIn(['scene', 'layers', layerID, 'lines', lineID, 'vertices', 1]);\n          var oldVertexID = v_id0 === vertexID ? v_id1 : v_id0;\n\n          var oldVertex = reducedState.getIn(['scene', 'layers', layerID, 'vertices', oldVertexID]);\n          var vertex = reducedState.getIn(['scene', 'layers', layerID, 'vertices', vertexID]);\n\n          var oldHoles = [];\n\n          var orderedVertices = GeometryUtils.orderVertices([oldVertex, vertex]);\n\n          var holes = reducedState.getIn(['scene', 'layers', layerID, 'lines', lineID, 'holes']).forEach(function (holeID) {\n            var hole = reducedState.getIn(['scene', 'layers', layerID, 'holes', holeID]);\n            var oldLineLength = GeometryUtils.pointsDistance(oldVertex.x, oldVertex.y, vertex.x, vertex.y);\n            var offset = GeometryUtils.samePoints(orderedVertices[1], reducedState.getIn(['scene', 'layers', layerID, 'lines', lineID, 'vertices', 1])) ? 1 - hole.offset : hole.offset;\n            var offsetPosition = GeometryUtils.extendLine(oldVertex.x, oldVertex.y, vertex.x, vertex.y, oldLineLength * offset);\n\n            oldHoles.push({ hole: hole, offsetPosition: offsetPosition });\n          });\n\n          var lineType = reducedState.getIn(['scene', 'layers', layerID, 'lines', lineID, 'type']);\n          var lineProps = reducedState.getIn(['scene', 'layers', layerID, 'lines', lineID, 'properties']);\n          var lineGroups = reducedState //get groups membership if present\n          .getIn(['scene', 'groups']).filter(function (group) {\n            var lines = group.getIn(['elements', layerID, 'lines']);\n            return lines && lines.contains(lineID);\n          });\n\n          reducedState = Layer.removeZeroLengthLines(reducedState, layerID).updatedState;\n          reducedState = Layer.mergeEqualsVertices(reducedState, layerID, vertexID).updatedState;\n          reducedState = Line.remove(reducedState, layerID, lineID).updatedState;\n\n          if (!GeometryUtils.samePoints(oldVertex, vertex)) {\n            var ret = Line.createAvoidingIntersections(reducedState, layerID, lineType, oldVertex.x, oldVertex.y, vertex.x, vertex.y, lineProps, oldHoles);\n\n            reducedState = ret.updatedState;\n\n            //re-add to old line's groups if present\n            ret.lines.forEach(function (addedLine) {\n              lineGroups.forEach(function (oldLineGroup) {\n                reducedState = Group.addElement(reducedState, oldLineGroup.id, layerID, 'lines', addedLine.id).updatedState;\n              });\n            });\n          }\n\n          return reducedState;\n        }, state);\n      }\n\n      state = Layer.detectAndUpdateAreas(state, layerID).updatedState;\n\n      state = state.merge({\n        mode: draggingSupport.get('previousMode'),\n        draggingSupport: null,\n        activeSnapElement: null,\n        snapElements: new List()\n      });\n\n      return { updatedState: state };\n    }\n  }]);\n\n  return Vertex;\n}();\n\nexport { Vertex as default };"]},"metadata":{},"sourceType":"module"}