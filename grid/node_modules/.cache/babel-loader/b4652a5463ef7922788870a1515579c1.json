{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nimport { SNAP_POINT, SNAP_LINE, SNAP_SEGMENT, SNAP_GRID, SNAP_GUIDE, addPointSnap, addLineSnap, addLineSegmentSnap, addGridSnap } from './snap';\nimport { GeometryUtils } from './export';\nimport { Map, List } from 'immutable';\nexport function sceneSnapElements(scene) {\n  var snapElements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new List();\n  var snapMask = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();\n  var width = scene.width,\n      height = scene.height;\n  var a = void 0,\n      b = void 0,\n      c = void 0;\n  return snapElements.withMutations(function (snapElements) {\n    scene.layers.forEach(function (layer) {\n      var lines = layer.lines,\n          vertices = layer.vertices;\n      vertices.forEach(function (_ref) {\n        var vertexID = _ref.id,\n            x = _ref.x,\n            y = _ref.y;\n\n        if (snapMask.get(SNAP_POINT)) {\n          addPointSnap(snapElements, x, y, 10, 10, vertexID);\n        }\n\n        if (snapMask.get(SNAP_LINE)) {\n          var _GeometryUtils$horizo = GeometryUtils.horizontalLine(y);\n\n          a = _GeometryUtils$horizo.a;\n          b = _GeometryUtils$horizo.b;\n          c = _GeometryUtils$horizo.c;\n          addLineSnap(snapElements, a, b, c, 10, 1, vertexID);\n\n          var _GeometryUtils$vertic = GeometryUtils.verticalLine(x);\n\n          a = _GeometryUtils$vertic.a;\n          b = _GeometryUtils$vertic.b;\n          c = _GeometryUtils$vertic.c;\n          addLineSnap(snapElements, a, b, c, 10, 1, vertexID);\n        }\n      });\n\n      if (snapMask.get(SNAP_SEGMENT)) {\n        lines.forEach(function (_ref2) {\n          var lineID = _ref2.id,\n              _ref2$vertices = _slicedToArray(_ref2.vertices, 2),\n              v0 = _ref2$vertices[0],\n              v1 = _ref2$vertices[1];\n\n          var _vertices$get = vertices.get(v0),\n              x1 = _vertices$get.x,\n              y1 = _vertices$get.y;\n\n          var _vertices$get2 = vertices.get(v1),\n              x2 = _vertices$get2.x,\n              y2 = _vertices$get2.y;\n\n          addLineSegmentSnap(snapElements, x1, y1, x2, y2, 20, 1, lineID);\n        });\n      }\n    });\n\n    if (snapMask.get(SNAP_GRID)) {\n      var divider = 5;\n      var gridCellSize = 100 / divider;\n      var xCycle = width / gridCellSize;\n      var yCycle = height / gridCellSize;\n\n      for (var x = 0; x < xCycle; x++) {\n        var xMul = x * gridCellSize;\n\n        for (var y = 0; y < yCycle; y++) {\n          var yMul = y * gridCellSize;\n          var onXCross = !(x % divider) ? true : false;\n          var onYCross = !(y % divider) ? true : false;\n          addGridSnap(snapElements, xMul, yMul, 10, onXCross && onYCross ? 15 : 10, null);\n        }\n      }\n    }\n\n    if (snapMask.get(SNAP_GUIDE)) {\n      var horizontal = scene.getIn(['guides', 'horizontal']);\n      var vertical = scene.getIn(['guides', 'vertical']);\n      var hValues = horizontal.valueSeq();\n      var vValues = vertical.valueSeq();\n      hValues.forEach(function (hVal) {\n        vValues.forEach(function (vVal) {\n          addPointSnap(snapElements, vVal, hVal, 10, 10);\n        });\n      });\n      hValues.forEach(function (hVal) {\n        return addLineSegmentSnap(snapElements, 0, hVal, width, hVal, 20, 1);\n      });\n      vValues.forEach(function (vVal) {\n        return addLineSegmentSnap(snapElements, vVal, 0, vVal, height, 20, 1);\n      });\n    }\n  });\n}","map":{"version":3,"sources":["/home/srihari/Desktop/Sparkplug_PandemicSparks/grid/node_modules/react-planner/es/utils/snap-scene.js"],"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","SNAP_POINT","SNAP_LINE","SNAP_SEGMENT","SNAP_GRID","SNAP_GUIDE","addPointSnap","addLineSnap","addLineSegmentSnap","addGridSnap","GeometryUtils","Map","List","sceneSnapElements","scene","snapElements","arguments","snapMask","width","height","a","b","c","withMutations","layers","forEach","layer","lines","vertices","_ref","vertexID","id","x","y","get","_GeometryUtils$horizo","horizontalLine","_GeometryUtils$vertic","verticalLine","_ref2","lineID","_ref2$vertices","v0","v1","_vertices$get","x1","y1","_vertices$get2","x2","y2","divider","gridCellSize","xCycle","yCycle","xMul","yMul","onXCross","onYCross","horizontal","getIn","vertical","hValues","valueSeq","vValues","hVal","vVal"],"mappings":"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","sourcesContent":["var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nimport { SNAP_POINT, SNAP_LINE, SNAP_SEGMENT, SNAP_GRID, SNAP_GUIDE, addPointSnap, addLineSnap, addLineSegmentSnap, addGridSnap } from './snap';\nimport { GeometryUtils } from './export';\nimport { Map, List } from 'immutable';\n\nexport function sceneSnapElements(scene) {\n  var snapElements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new List();\n  var snapMask = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();\n  var width = scene.width,\n      height = scene.height;\n\n\n  var a = void 0,\n      b = void 0,\n      c = void 0;\n  return snapElements.withMutations(function (snapElements) {\n    scene.layers.forEach(function (layer) {\n      var lines = layer.lines,\n          vertices = layer.vertices;\n\n\n      vertices.forEach(function (_ref) {\n        var vertexID = _ref.id,\n            x = _ref.x,\n            y = _ref.y;\n\n\n        if (snapMask.get(SNAP_POINT)) {\n          addPointSnap(snapElements, x, y, 10, 10, vertexID);\n        }\n\n        if (snapMask.get(SNAP_LINE)) {\n          var _GeometryUtils$horizo = GeometryUtils.horizontalLine(y);\n\n          a = _GeometryUtils$horizo.a;\n          b = _GeometryUtils$horizo.b;\n          c = _GeometryUtils$horizo.c;\n\n          addLineSnap(snapElements, a, b, c, 10, 1, vertexID);\n\n          var _GeometryUtils$vertic = GeometryUtils.verticalLine(x);\n\n          a = _GeometryUtils$vertic.a;\n          b = _GeometryUtils$vertic.b;\n          c = _GeometryUtils$vertic.c;\n\n          addLineSnap(snapElements, a, b, c, 10, 1, vertexID);\n        }\n      });\n\n      if (snapMask.get(SNAP_SEGMENT)) {\n        lines.forEach(function (_ref2) {\n          var lineID = _ref2.id,\n              _ref2$vertices = _slicedToArray(_ref2.vertices, 2),\n              v0 = _ref2$vertices[0],\n              v1 = _ref2$vertices[1];\n\n          var _vertices$get = vertices.get(v0),\n              x1 = _vertices$get.x,\n              y1 = _vertices$get.y;\n\n          var _vertices$get2 = vertices.get(v1),\n              x2 = _vertices$get2.x,\n              y2 = _vertices$get2.y;\n\n          addLineSegmentSnap(snapElements, x1, y1, x2, y2, 20, 1, lineID);\n        });\n      }\n    });\n\n    if (snapMask.get(SNAP_GRID)) {\n      var divider = 5;\n      var gridCellSize = 100 / divider;\n      var xCycle = width / gridCellSize;\n      var yCycle = height / gridCellSize;\n\n      for (var x = 0; x < xCycle; x++) {\n        var xMul = x * gridCellSize;\n\n        for (var y = 0; y < yCycle; y++) {\n          var yMul = y * gridCellSize;\n\n          var onXCross = !(x % divider) ? true : false;\n          var onYCross = !(y % divider) ? true : false;\n\n          addGridSnap(snapElements, xMul, yMul, 10, onXCross && onYCross ? 15 : 10, null);\n        }\n      }\n    }\n\n    if (snapMask.get(SNAP_GUIDE)) {\n\n      var horizontal = scene.getIn(['guides', 'horizontal']);\n      var vertical = scene.getIn(['guides', 'vertical']);\n\n      var hValues = horizontal.valueSeq();\n      var vValues = vertical.valueSeq();\n\n      hValues.forEach(function (hVal) {\n        vValues.forEach(function (vVal) {\n          addPointSnap(snapElements, vVal, hVal, 10, 10);\n        });\n      });\n\n      hValues.forEach(function (hVal) {\n        return addLineSegmentSnap(snapElements, 0, hVal, width, hVal, 20, 1);\n      });\n      vValues.forEach(function (vVal) {\n        return addLineSegmentSnap(snapElements, vVal, 0, vVal, height, 20, 1);\n      });\n    }\n  });\n}"]},"metadata":{},"sourceType":"module"}