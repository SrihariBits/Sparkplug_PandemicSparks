{"ast":null,"code":"import { TextureLoader, Mesh, RepeatWrapping, Vector2, BoxGeometry, MeshBasicMaterial, Group } from 'three';\nimport ThreeBSP from '../../utils/threeCSG.es6';\nimport { verticesDistance } from '../../utils/geometry';\nimport * as SharedStyle from '../../shared-style';\nvar halfPI = Math.PI / 2;\n/**\n * Apply a texture to a wall face\n * @param material: The material of the face\n * @param texture: The texture to load\n * @param length: The lenght of the face\n * @param height: The height of the face\n */\n\nvar applyTexture = function applyTexture(material, texture, length, height) {\n  var loader = new TextureLoader();\n\n  if (texture) {\n    material.map = loader.load(texture.uri);\n    material.needsUpdate = true;\n    material.map.wrapS = RepeatWrapping;\n    material.map.wrapT = RepeatWrapping;\n    material.map.repeat.set(length * texture.lengthRepeatScale, height * texture.heightRepeatScale);\n\n    if (texture.normal) {\n      material.normalMap = loader.load(texture.normal.uri);\n      material.normalScale = new Vector2(texture.normal.normalScaleX, texture.normal.normalScaleY);\n      material.normalMap.wrapS = RepeatWrapping;\n      material.normalMap.wrapT = RepeatWrapping;\n      material.normalMap.repeat.set(length * texture.normal.lengthRepeatScale, height * texture.normal.heightRepeatScale);\n    }\n  }\n};\n\nexport function buildWall(element, layer, scene, textures) {\n  // Get the two vertices of the wall\n  var vertex0 = layer.vertices.get(element.vertices.get(0));\n  var vertex1 = layer.vertices.get(element.vertices.get(1));\n  var inverted = false; // The first vertex is the smaller one\n\n  if (vertex0.x > vertex1.x) {\n    var app = vertex0;\n    vertex0 = vertex1;\n    vertex1 = app;\n    inverted = true;\n  } // Get height and thickness of the wall converting them into the current scene units\n\n\n  var height = element.properties.getIn(['height', 'length']);\n  var thickness = element.properties.getIn(['thickness', 'length']);\n  var halfThickness = thickness / 2;\n  var faceThickness = 0.2;\n  var faceDistance = 1;\n  var distance = verticesDistance(vertex0, vertex1);\n  var halfDistance = distance / 2;\n  var soulMaterial = new MeshBasicMaterial({\n    color: element.selected ? SharedStyle.MESH_SELECTED : 0xD3D3D3\n  });\n  var soul = new Mesh(new BoxGeometry(distance, height, thickness), soulMaterial);\n  var alpha = Math.asin((vertex1.y - vertex0.y) / distance);\n  var sinAlpha = Math.sin(alpha);\n  var cosAlpha = Math.cos(alpha);\n  soul.position.y += height / 2;\n  soul.position.x += halfDistance * cosAlpha;\n  soul.position.z -= halfDistance * sinAlpha;\n  soul.rotation.y = alpha;\n  element.holes.forEach(function (holeID) {\n    var holeData = layer.holes.get(holeID);\n    var holeWidth = holeData.properties.getIn(['width', 'length']);\n    var holeHeight = holeData.properties.getIn(['height', 'length']);\n    var holeAltitude = holeData.properties.getIn(['altitude', 'length']);\n    var offset = inverted ? 1 - holeData.offset : holeData.offset;\n    var holeDistance = offset * distance;\n    var holeGeometry = new BoxGeometry(holeWidth, holeHeight, thickness);\n    var holeMesh = new Mesh(holeGeometry);\n    holeMesh.position.y += holeHeight / 2 + holeAltitude;\n    holeMesh.position.x += holeDistance * cosAlpha;\n    holeMesh.position.z -= holeDistance * sinAlpha;\n    holeMesh.rotation.y = alpha;\n    var wallBSP = new ThreeBSP(soul);\n    var holeBSP = new ThreeBSP(holeMesh);\n    var wallWithHoleBSP = wallBSP.subtract(holeBSP);\n    soul = wallWithHoleBSP.toMesh(soulMaterial);\n  });\n  soul.name = 'soul';\n  var frontMaterial = new MeshBasicMaterial();\n  var backMaterial = new MeshBasicMaterial();\n  applyTexture(frontMaterial, textures[element.properties.get('textureB')], distance, height);\n  applyTexture(backMaterial, textures[element.properties.get('textureA')], distance, height);\n  var scaleFactor = faceThickness / thickness;\n  var texturedFaceDistance = halfThickness + faceDistance;\n  var frontFace = soul.clone();\n  frontFace.material = frontMaterial;\n  frontFace.scale.set(1, 1, scaleFactor);\n  frontFace.position.x += texturedFaceDistance * Math.cos(alpha - halfPI);\n  frontFace.position.z -= texturedFaceDistance * Math.sin(alpha - halfPI);\n  frontFace.name = 'frontFace';\n  var backFace = soul.clone();\n  backFace.material = backMaterial;\n  backFace.scale.set(1, 1, scaleFactor);\n  backFace.position.x += texturedFaceDistance * Math.cos(alpha + halfPI);\n  backFace.position.z -= texturedFaceDistance * Math.sin(alpha + halfPI);\n  backFace.name = 'backFace';\n  var merged = new Group();\n  merged.add(soul, frontFace, backFace);\n  return Promise.resolve(merged);\n}\nexport function updatedWall(element, layer, scene, textures, mesh, oldElement, differences, selfDestroy, selfBuild) {\n  var noPerf = function noPerf() {\n    selfDestroy();\n    return selfBuild();\n  };\n\n  var soul = mesh.getObjectByName('soul');\n  var frontFace = mesh.getObjectByName('frontFace');\n  var backFace = mesh.getObjectByName('backFace');\n\n  if (differences[0] == 'selected') {\n    soul.material = new MeshBasicMaterial({\n      color: element.selected ? SharedStyle.MESH_SELECTED : 0xD3D3D3\n    });\n  } else if (differences[0] == 'properties') {\n    if (differences[1] == 'thickness') {\n      var newThickness = element.getIn(['properties', 'thickness', 'length']);\n      var oldThickness = oldElement.getIn(['properties', 'thickness', 'length']);\n      var halfNewThickness = newThickness / 2;\n      var texturedFaceDistance = halfNewThickness + 1;\n      var originalThickness = oldThickness / soul.scale.z;\n      var alpha = soul.rotation.y;\n      var xTemp = texturedFaceDistance * Math.cos(alpha - halfPI);\n      var zTemp = texturedFaceDistance * Math.sin(alpha - halfPI);\n      soul.scale.set(1, 1, newThickness / originalThickness);\n      frontFace.position.x = soul.position.x + xTemp;\n      frontFace.position.z = soul.position.z + zTemp;\n      backFace.position.x = soul.position.x - xTemp;\n      backFace.position.z = soul.position.z - zTemp;\n    } else return noPerf();\n  } else return noPerf();\n\n  return Promise.resolve(mesh);\n}","map":{"version":3,"sources":["/home/srihari/Desktop/Sparkplug_PandemicSparks/grid/node_modules/react-planner/es/catalog/factories/wall-factory-3d.js"],"names":["TextureLoader","Mesh","RepeatWrapping","Vector2","BoxGeometry","MeshBasicMaterial","Group","ThreeBSP","verticesDistance","SharedStyle","halfPI","Math","PI","applyTexture","material","texture","length","height","loader","map","load","uri","needsUpdate","wrapS","wrapT","repeat","set","lengthRepeatScale","heightRepeatScale","normal","normalMap","normalScale","normalScaleX","normalScaleY","buildWall","element","layer","scene","textures","vertex0","vertices","get","vertex1","inverted","x","app","properties","getIn","thickness","halfThickness","faceThickness","faceDistance","distance","halfDistance","soulMaterial","color","selected","MESH_SELECTED","soul","alpha","asin","y","sinAlpha","sin","cosAlpha","cos","position","z","rotation","holes","forEach","holeID","holeData","holeWidth","holeHeight","holeAltitude","offset","holeDistance","holeGeometry","holeMesh","wallBSP","holeBSP","wallWithHoleBSP","subtract","toMesh","name","frontMaterial","backMaterial","scaleFactor","texturedFaceDistance","frontFace","clone","scale","backFace","merged","add","Promise","resolve","updatedWall","mesh","oldElement","differences","selfDestroy","selfBuild","noPerf","getObjectByName","newThickness","oldThickness","halfNewThickness","originalThickness","xTemp","zTemp"],"mappings":"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","sourcesContent":["import { TextureLoader, Mesh, RepeatWrapping, Vector2, BoxGeometry, MeshBasicMaterial, Group } from 'three';\n\nimport ThreeBSP from '../../utils/threeCSG.es6';\nimport { verticesDistance } from '../../utils/geometry';\nimport * as SharedStyle from '../../shared-style';\n\nvar halfPI = Math.PI / 2;\n\n/**\n * Apply a texture to a wall face\n * @param material: The material of the face\n * @param texture: The texture to load\n * @param length: The lenght of the face\n * @param height: The height of the face\n */\nvar applyTexture = function applyTexture(material, texture, length, height) {\n  var loader = new TextureLoader();\n\n  if (texture) {\n    material.map = loader.load(texture.uri);\n    material.needsUpdate = true;\n    material.map.wrapS = RepeatWrapping;\n    material.map.wrapT = RepeatWrapping;\n    material.map.repeat.set(length * texture.lengthRepeatScale, height * texture.heightRepeatScale);\n\n    if (texture.normal) {\n      material.normalMap = loader.load(texture.normal.uri);\n      material.normalScale = new Vector2(texture.normal.normalScaleX, texture.normal.normalScaleY);\n      material.normalMap.wrapS = RepeatWrapping;\n      material.normalMap.wrapT = RepeatWrapping;\n      material.normalMap.repeat.set(length * texture.normal.lengthRepeatScale, height * texture.normal.heightRepeatScale);\n    }\n  }\n};\n\nexport function buildWall(element, layer, scene, textures) {\n  // Get the two vertices of the wall\n  var vertex0 = layer.vertices.get(element.vertices.get(0));\n  var vertex1 = layer.vertices.get(element.vertices.get(1));\n  var inverted = false;\n\n  // The first vertex is the smaller one\n  if (vertex0.x > vertex1.x) {\n    var app = vertex0;\n    vertex0 = vertex1;\n    vertex1 = app;\n    inverted = true;\n  }\n\n  // Get height and thickness of the wall converting them into the current scene units\n  var height = element.properties.getIn(['height', 'length']);\n  var thickness = element.properties.getIn(['thickness', 'length']);\n  var halfThickness = thickness / 2;\n  var faceThickness = 0.2;\n  var faceDistance = 1;\n\n  var distance = verticesDistance(vertex0, vertex1);\n  var halfDistance = distance / 2;\n\n  var soulMaterial = new MeshBasicMaterial({ color: element.selected ? SharedStyle.MESH_SELECTED : 0xD3D3D3 });\n  var soul = new Mesh(new BoxGeometry(distance, height, thickness), soulMaterial);\n\n  var alpha = Math.asin((vertex1.y - vertex0.y) / distance);\n\n  var sinAlpha = Math.sin(alpha);\n  var cosAlpha = Math.cos(alpha);\n\n  soul.position.y += height / 2;\n  soul.position.x += halfDistance * cosAlpha;\n  soul.position.z -= halfDistance * sinAlpha;\n\n  soul.rotation.y = alpha;\n\n  element.holes.forEach(function (holeID) {\n    var holeData = layer.holes.get(holeID);\n\n    var holeWidth = holeData.properties.getIn(['width', 'length']);\n    var holeHeight = holeData.properties.getIn(['height', 'length']);\n    var holeAltitude = holeData.properties.getIn(['altitude', 'length']);\n    var offset = inverted ? 1 - holeData.offset : holeData.offset;\n    var holeDistance = offset * distance;\n\n    var holeGeometry = new BoxGeometry(holeWidth, holeHeight, thickness);\n    var holeMesh = new Mesh(holeGeometry);\n\n    holeMesh.position.y += holeHeight / 2 + holeAltitude;\n    holeMesh.position.x += holeDistance * cosAlpha;\n    holeMesh.position.z -= holeDistance * sinAlpha;\n\n    holeMesh.rotation.y = alpha;\n\n    var wallBSP = new ThreeBSP(soul);\n    var holeBSP = new ThreeBSP(holeMesh);\n\n    var wallWithHoleBSP = wallBSP.subtract(holeBSP);\n    soul = wallWithHoleBSP.toMesh(soulMaterial);\n  });\n\n  soul.name = 'soul';\n\n  var frontMaterial = new MeshBasicMaterial();\n  var backMaterial = new MeshBasicMaterial();\n\n  applyTexture(frontMaterial, textures[element.properties.get('textureB')], distance, height);\n  applyTexture(backMaterial, textures[element.properties.get('textureA')], distance, height);\n\n  var scaleFactor = faceThickness / thickness;\n  var texturedFaceDistance = halfThickness + faceDistance;\n\n  var frontFace = soul.clone();\n  frontFace.material = frontMaterial;\n  frontFace.scale.set(1, 1, scaleFactor);\n  frontFace.position.x += texturedFaceDistance * Math.cos(alpha - halfPI);\n  frontFace.position.z -= texturedFaceDistance * Math.sin(alpha - halfPI);\n  frontFace.name = 'frontFace';\n\n  var backFace = soul.clone();\n  backFace.material = backMaterial;\n  backFace.scale.set(1, 1, scaleFactor);\n  backFace.position.x += texturedFaceDistance * Math.cos(alpha + halfPI);\n  backFace.position.z -= texturedFaceDistance * Math.sin(alpha + halfPI);\n  backFace.name = 'backFace';\n\n  var merged = new Group();\n  merged.add(soul, frontFace, backFace);\n\n  return Promise.resolve(merged);\n}\n\nexport function updatedWall(element, layer, scene, textures, mesh, oldElement, differences, selfDestroy, selfBuild) {\n  var noPerf = function noPerf() {\n    selfDestroy();return selfBuild();\n  };\n\n  var soul = mesh.getObjectByName('soul');\n  var frontFace = mesh.getObjectByName('frontFace');\n  var backFace = mesh.getObjectByName('backFace');\n\n  if (differences[0] == 'selected') {\n    soul.material = new MeshBasicMaterial({ color: element.selected ? SharedStyle.MESH_SELECTED : 0xD3D3D3 });\n  } else if (differences[0] == 'properties') {\n\n    if (differences[1] == 'thickness') {\n      var newThickness = element.getIn(['properties', 'thickness', 'length']);\n      var oldThickness = oldElement.getIn(['properties', 'thickness', 'length']);\n      var halfNewThickness = newThickness / 2;\n      var texturedFaceDistance = halfNewThickness + 1;\n      var originalThickness = oldThickness / soul.scale.z;\n      var alpha = soul.rotation.y;\n\n      var xTemp = texturedFaceDistance * Math.cos(alpha - halfPI);\n      var zTemp = texturedFaceDistance * Math.sin(alpha - halfPI);\n\n      soul.scale.set(1, 1, newThickness / originalThickness);\n\n      frontFace.position.x = soul.position.x + xTemp;\n      frontFace.position.z = soul.position.z + zTemp;\n\n      backFace.position.x = soul.position.x - xTemp;\n      backFace.position.z = soul.position.z - zTemp;\n    } else return noPerf();\n  } else return noPerf();\n\n  return Promise.resolve(mesh);\n}"]},"metadata":{},"sourceType":"module"}