{"ast":null,"code":"import { Shape, MeshPhongMaterial, ShapeGeometry, Box3, TextureLoader, BackSide, FrontSide, Object3D, Mesh, MeshBasicMaterial, RepeatWrapping, Vector2, DoubleSide } from 'three';\nimport * as SharedStyle from '../../shared-style';\n/**\n * Apply a texture to a wall face\n * @param material: The material of the face\n * @param texture: The texture to load\n * @param length: The lenght of the face\n * @param height: The height of the face\n */\n\nvar applyTexture = function applyTexture(material, texture, length, height) {\n  var loader = new TextureLoader();\n\n  if (texture) {\n    material.map = loader.load(texture.uri);\n    material.needsUpdate = true;\n    material.map.wrapS = RepeatWrapping;\n    material.map.wrapT = RepeatWrapping;\n    material.map.repeat.set(length * texture.lengthRepeatScale, height * texture.heightRepeatScale);\n\n    if (texture.normal) {\n      material.normalMap = loader.load(texture.normal.uri);\n      material.normalScale = new Vector2(texture.normal.normalScaleX, texture.normal.normalScaleY);\n      material.normalMap.wrapS = RepeatWrapping;\n      material.normalMap.wrapT = RepeatWrapping;\n      material.normalMap.repeat.set(length * texture.normal.lengthRepeatScale, height * texture.normal.heightRepeatScale);\n    }\n  }\n};\n/**\n * Function that assign UV coordinates to a geometry\n * @param geometry\n */\n\n\nvar assignUVs = function assignUVs(geometry) {\n  geometry.computeBoundingBox();\n  var _geometry$boundingBox = geometry.boundingBox,\n      min = _geometry$boundingBox.min,\n      max = _geometry$boundingBox.max;\n  var offset = new Vector2(0 - min.x, 0 - min.y);\n  var range = new Vector2(max.x - min.x, max.y - min.y);\n  geometry.faceVertexUvs[0] = geometry.faces.map(function (face) {\n    var v1 = geometry.vertices[face.a];\n    var v2 = geometry.vertices[face.b];\n    var v3 = geometry.vertices[face.c];\n    return [new Vector2((v1.x + offset.x) / range.x, (v1.y + offset.y) / range.y), new Vector2((v2.x + offset.x) / range.x, (v2.y + offset.y) / range.y), new Vector2((v3.x + offset.x) / range.x, (v3.y + offset.y) / range.y)];\n  });\n  geometry.uvsNeedUpdate = true;\n};\n\nexport function createArea(element, layer, scene, textures) {\n  var vertices = [];\n  element.vertices.forEach(function (vertexID) {\n    vertices.push(layer.vertices.get(vertexID));\n  });\n  var textureName = element.properties.get('texture');\n  var color = element.properties.get('patternColor');\n\n  if (element.selected) {\n    color = SharedStyle.AREA_MESH_COLOR.selected;\n  } else if (textureName && textureName !== 'none') {\n    color = SharedStyle.AREA_MESH_COLOR.unselected;\n  }\n\n  var shape = new Shape();\n  shape.moveTo(vertices[0].x, vertices[0].y);\n\n  for (var i = 1; i < vertices.length; i++) {\n    shape.lineTo(vertices[i].x, vertices[i].y);\n  }\n\n  var areaMaterial = new MeshPhongMaterial({\n    side: DoubleSide,\n    color: color\n  });\n  /* Create holes for the area */\n\n  element.holes.forEach(function (holeID) {\n    var holeCoords = [];\n    layer.getIn(['areas', holeID, 'vertices']).forEach(function (vertexID) {\n      var _layer$getIn = layer.getIn(['vertices', vertexID]),\n          x = _layer$getIn.x,\n          y = _layer$getIn.y;\n\n      holeCoords.push([x, y]);\n    });\n    holeCoords = holeCoords.reverse();\n    var holeShape = createShape(holeCoords);\n    shape.holes.push(holeShape);\n  });\n  var shapeGeometry = new ShapeGeometry(shape);\n  assignUVs(shapeGeometry);\n  var boundingBox = new Box3().setFromObject(new Mesh(shapeGeometry, new MeshBasicMaterial()));\n  var width = boundingBox.max.x - boundingBox.min.x;\n  var height = boundingBox.max.y - boundingBox.min.y;\n  var texture = textures[textureName];\n  applyTexture(areaMaterial, texture, width, height);\n  var area = new Mesh(shapeGeometry, areaMaterial);\n  area.rotation.x -= Math.PI / 2;\n  area.name = 'floor';\n  return Promise.resolve(area);\n}\nexport function updatedArea(element, layer, scene, textures, mesh, oldElement, differences, selfDestroy, selfBuild) {\n  var noPerf = function noPerf() {\n    selfDestroy();\n    return selfBuild();\n  };\n\n  var floor = mesh.getObjectByName('floor');\n\n  if (differences[0] == 'selected') {\n    var color = element.selected ? SharedStyle.AREA_MESH_COLOR.selected : element.properties.get('patternColor') || SharedStyle.AREA_MESH_COLOR.unselected;\n    floor.material.color.set(color);\n  } else if (differences[0] == 'properties') {\n    if (differences[1] === 'texture') {\n      return noPerf();\n    }\n  } else return noPerf();\n\n  return Promise.resolve(mesh);\n}\n/**\n * This function will create a shape given a list of coordinates\n * @param shapeCoords\n * @returns {Shape}\n */\n\nvar createShape = function createShape(shapeCoords) {\n  var shape = new Shape();\n  shape.moveTo(shapeCoords[0][0], shapeCoords[0][1]);\n\n  for (var i = 1; i < shapeCoords.length; i++) {\n    shape.lineTo(shapeCoords[i][0], shapeCoords[i][1]);\n  }\n\n  return shape;\n};","map":{"version":3,"sources":["/home/srihari/Desktop/Sparkplug_PandemicSparks/grid/node_modules/react-planner/es/catalog/factories/area-factory-3d.js"],"names":["Shape","MeshPhongMaterial","ShapeGeometry","Box3","TextureLoader","BackSide","FrontSide","Object3D","Mesh","MeshBasicMaterial","RepeatWrapping","Vector2","DoubleSide","SharedStyle","applyTexture","material","texture","length","height","loader","map","load","uri","needsUpdate","wrapS","wrapT","repeat","set","lengthRepeatScale","heightRepeatScale","normal","normalMap","normalScale","normalScaleX","normalScaleY","assignUVs","geometry","computeBoundingBox","_geometry$boundingBox","boundingBox","min","max","offset","x","y","range","faceVertexUvs","faces","face","v1","vertices","a","v2","b","v3","c","uvsNeedUpdate","createArea","element","layer","scene","textures","forEach","vertexID","push","get","textureName","properties","color","selected","AREA_MESH_COLOR","unselected","shape","moveTo","i","lineTo","areaMaterial","side","holes","holeID","holeCoords","getIn","_layer$getIn","reverse","holeShape","createShape","shapeGeometry","setFromObject","width","area","rotation","Math","PI","name","Promise","resolve","updatedArea","mesh","oldElement","differences","selfDestroy","selfBuild","noPerf","floor","getObjectByName","shapeCoords"],"mappings":"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","sourcesContent":["import { Shape, MeshPhongMaterial, ShapeGeometry, Box3, TextureLoader, BackSide, FrontSide, Object3D, Mesh, MeshBasicMaterial, RepeatWrapping, Vector2, DoubleSide } from 'three';\nimport * as SharedStyle from '../../shared-style';\n\n/**\n * Apply a texture to a wall face\n * @param material: The material of the face\n * @param texture: The texture to load\n * @param length: The lenght of the face\n * @param height: The height of the face\n */\nvar applyTexture = function applyTexture(material, texture, length, height) {\n  var loader = new TextureLoader();\n\n  if (texture) {\n    material.map = loader.load(texture.uri);\n    material.needsUpdate = true;\n    material.map.wrapS = RepeatWrapping;\n    material.map.wrapT = RepeatWrapping;\n    material.map.repeat.set(length * texture.lengthRepeatScale, height * texture.heightRepeatScale);\n\n    if (texture.normal) {\n      material.normalMap = loader.load(texture.normal.uri);\n      material.normalScale = new Vector2(texture.normal.normalScaleX, texture.normal.normalScaleY);\n      material.normalMap.wrapS = RepeatWrapping;\n      material.normalMap.wrapT = RepeatWrapping;\n      material.normalMap.repeat.set(length * texture.normal.lengthRepeatScale, height * texture.normal.heightRepeatScale);\n    }\n  }\n};\n\n/**\n * Function that assign UV coordinates to a geometry\n * @param geometry\n */\nvar assignUVs = function assignUVs(geometry) {\n  geometry.computeBoundingBox();\n\n  var _geometry$boundingBox = geometry.boundingBox,\n      min = _geometry$boundingBox.min,\n      max = _geometry$boundingBox.max;\n\n\n  var offset = new Vector2(0 - min.x, 0 - min.y);\n  var range = new Vector2(max.x - min.x, max.y - min.y);\n\n  geometry.faceVertexUvs[0] = geometry.faces.map(function (face) {\n\n    var v1 = geometry.vertices[face.a];\n    var v2 = geometry.vertices[face.b];\n    var v3 = geometry.vertices[face.c];\n\n    return [new Vector2((v1.x + offset.x) / range.x, (v1.y + offset.y) / range.y), new Vector2((v2.x + offset.x) / range.x, (v2.y + offset.y) / range.y), new Vector2((v3.x + offset.x) / range.x, (v3.y + offset.y) / range.y)];\n  });\n\n  geometry.uvsNeedUpdate = true;\n};\n\nexport function createArea(element, layer, scene, textures) {\n  var vertices = [];\n\n  element.vertices.forEach(function (vertexID) {\n    vertices.push(layer.vertices.get(vertexID));\n  });\n\n  var textureName = element.properties.get('texture');\n  var color = element.properties.get('patternColor');\n\n  if (element.selected) {\n    color = SharedStyle.AREA_MESH_COLOR.selected;\n  } else if (textureName && textureName !== 'none') {\n    color = SharedStyle.AREA_MESH_COLOR.unselected;\n  }\n\n  var shape = new Shape();\n  shape.moveTo(vertices[0].x, vertices[0].y);\n  for (var i = 1; i < vertices.length; i++) {\n    shape.lineTo(vertices[i].x, vertices[i].y);\n  }\n\n  var areaMaterial = new MeshPhongMaterial({ side: DoubleSide, color: color });\n\n  /* Create holes for the area */\n  element.holes.forEach(function (holeID) {\n    var holeCoords = [];\n    layer.getIn(['areas', holeID, 'vertices']).forEach(function (vertexID) {\n      var _layer$getIn = layer.getIn(['vertices', vertexID]),\n          x = _layer$getIn.x,\n          y = _layer$getIn.y;\n\n      holeCoords.push([x, y]);\n    });\n    holeCoords = holeCoords.reverse();\n    var holeShape = createShape(holeCoords);\n    shape.holes.push(holeShape);\n  });\n\n  var shapeGeometry = new ShapeGeometry(shape);\n  assignUVs(shapeGeometry);\n\n  var boundingBox = new Box3().setFromObject(new Mesh(shapeGeometry, new MeshBasicMaterial()));\n\n  var width = boundingBox.max.x - boundingBox.min.x;\n  var height = boundingBox.max.y - boundingBox.min.y;\n\n  var texture = textures[textureName];\n\n  applyTexture(areaMaterial, texture, width, height);\n\n  var area = new Mesh(shapeGeometry, areaMaterial);\n\n  area.rotation.x -= Math.PI / 2;\n  area.name = 'floor';\n\n  return Promise.resolve(area);\n}\n\nexport function updatedArea(element, layer, scene, textures, mesh, oldElement, differences, selfDestroy, selfBuild) {\n  var noPerf = function noPerf() {\n    selfDestroy();return selfBuild();\n  };\n  var floor = mesh.getObjectByName('floor');\n\n  if (differences[0] == 'selected') {\n    var color = element.selected ? SharedStyle.AREA_MESH_COLOR.selected : element.properties.get('patternColor') || SharedStyle.AREA_MESH_COLOR.unselected;\n    floor.material.color.set(color);\n  } else if (differences[0] == 'properties') {\n    if (differences[1] === 'texture') {\n      return noPerf();\n    }\n  } else return noPerf();\n\n  return Promise.resolve(mesh);\n}\n\n/**\n * This function will create a shape given a list of coordinates\n * @param shapeCoords\n * @returns {Shape}\n */\nvar createShape = function createShape(shapeCoords) {\n  var shape = new Shape();\n  shape.moveTo(shapeCoords[0][0], shapeCoords[0][1]);\n  for (var i = 1; i < shapeCoords.length; i++) {\n    shape.lineTo(shapeCoords[i][0], shapeCoords[i][1]);\n  }\n  return shape;\n};"]},"metadata":{},"sourceType":"module"}