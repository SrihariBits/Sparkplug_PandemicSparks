{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nimport { Map, List, fromJS } from 'immutable';\nimport { Group, Layer, Hole, Vertex } from './export';\nimport { IDBroker, NameGenerator, GeometryUtils, SnapUtils, SnapSceneUtils } from '../utils/export';\nimport { MODE_IDLE, MODE_WAITING_DRAWING_LINE, MODE_DRAWING_LINE, MODE_DRAGGING_LINE } from '../constants';\n\nvar Line = function () {\n  function Line() {\n    _classCallCheck(this, Line);\n  }\n\n  _createClass(Line, null, [{\n    key: 'create',\n    value: function create(state, layerID, type, x0, y0, x1, y1, properties) {\n      var lineID = IDBroker.acquireID();\n\n      var _Vertex$add = Vertex.add(state, layerID, x0, y0, 'lines', lineID),\n          stateV0 = _Vertex$add.updatedState,\n          v0 = _Vertex$add.vertex;\n\n      var _Vertex$add2 = Vertex.add(stateV0, layerID, x1, y1, 'lines', lineID),\n          stateV1 = _Vertex$add2.updatedState,\n          v1 = _Vertex$add2.vertex;\n\n      state = stateV1;\n      var line = state.catalog.factoryElement(type, {\n        id: lineID,\n        name: NameGenerator.generateName('lines', state.catalog.getIn(['elements', type, 'info', 'title'])),\n        vertices: new List([v0.id, v1.id]),\n        type: type\n      }, properties);\n      state = state.setIn(['scene', 'layers', layerID, 'lines', lineID], line);\n      return {\n        updatedState: state,\n        line: line\n      };\n    }\n  }, {\n    key: 'select',\n    value: function select(state, layerID, lineID) {\n      state = Layer.select(state, layerID).updatedState;\n      var line = state.getIn(['scene', 'layers', layerID, 'lines', lineID]);\n      state = Layer.selectElement(state, layerID, 'lines', lineID).updatedState;\n      state = Layer.selectElement(state, layerID, 'vertices', line.vertices.get(0)).updatedState;\n      state = Layer.selectElement(state, layerID, 'vertices', line.vertices.get(1)).updatedState;\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'remove',\n    value: function remove(state, layerID, lineID) {\n      var line = state.getIn(['scene', 'layers', layerID, 'lines', lineID]);\n\n      if (line) {\n        state = this.unselect(state, layerID, lineID).updatedState;\n        line.holes.forEach(function (holeID) {\n          return state = Hole.remove(state, layerID, holeID).updatedState;\n        });\n        state = Layer.removeElement(state, layerID, 'lines', lineID).updatedState;\n        line.vertices.forEach(function (vertexID) {\n          return state = Vertex.remove(state, layerID, vertexID, 'lines', lineID).updatedState;\n        });\n        state.getIn(['scene', 'groups']).forEach(function (group) {\n          return state = Group.removeElement(state, group.id, layerID, 'lines', lineID).updatedState;\n        });\n      }\n\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'unselect',\n    value: function unselect(state, layerID, lineID) {\n      var line = state.getIn(['scene', 'layers', layerID, 'lines', lineID]);\n\n      if (line) {\n        state = Layer.unselect(state, layerID, 'vertices', line.vertices.get(0)).updatedState;\n        state = Layer.unselect(state, layerID, 'vertices', line.vertices.get(1)).updatedState;\n        state = Layer.unselect(state, layerID, 'lines', lineID).updatedState;\n      }\n\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'split',\n    value: function split(state, layerID, lineID, x, y) {\n      var line = state.getIn(['scene', 'layers', layerID, 'lines', lineID]);\n      var v0 = state.getIn(['scene', 'layers', layerID, 'vertices', line.vertices.get(0)]);\n      var v1 = state.getIn(['scene', 'layers', layerID, 'vertices', line.vertices.get(1)]);\n      var x0 = v0.x,\n          y0 = v0.y;\n      var x1 = v1.x,\n          y1 = v1.y;\n\n      var _Line$create = Line.create(state, layerID, line.type, x0, y0, x, y, line.get('properties')),\n          stateL1 = _Line$create.updatedState,\n          line0 = _Line$create.line;\n\n      var _Line$create2 = Line.create(stateL1, layerID, line.type, x1, y1, x, y, line.get('properties')),\n          stateL2 = _Line$create2.updatedState,\n          line1 = _Line$create2.line;\n\n      state = stateL2;\n      var splitPointOffset = GeometryUtils.pointPositionOnLineSegment(x0, y0, x1, y1, x, y);\n      var minVertex = GeometryUtils.minVertex(v0, v1);\n      line.holes.forEach(function (holeID) {\n        var hole = state.getIn(['scene', 'layers', layerID, 'holes', holeID]);\n        var holeOffset = hole.offset;\n\n        if (minVertex.x === x1 && minVertex.y === y1) {\n          splitPointOffset = 1 - splitPointOffset;\n          holeOffset = 1 - hole.offset;\n        }\n\n        if (holeOffset < splitPointOffset) {\n          var offset = holeOffset / splitPointOffset;\n\n          if (minVertex.x === x1 && minVertex.y === y1) {\n            offset = 1 - offset;\n          }\n\n          state = Hole.create(state, layerID, hole.type, line0.id, offset, hole.properties).updatedState;\n        } else {\n          var _offset = (holeOffset - splitPointOffset) / (1 - splitPointOffset);\n\n          if (minVertex.x === x1 && minVertex.y === y1) {\n            _offset = 1 - _offset;\n          }\n\n          state = Hole.create(state, layerID, hole.type, line1.id, _offset, hole.properties).updatedState;\n        }\n      }); //add splitted lines to the original line's group\n\n      var lineGroups = state.getIn(['scene', 'groups']).filter(function (group) {\n        var lines = group.getIn(['elements', layerID, 'lines']);\n        return lines && lines.contains(lineID);\n      });\n      lineGroups.forEach(function (group) {\n        state = Group.addElement(state, group.id, layerID, 'lines', line0.id).updatedState;\n        state = Group.addElement(state, group.id, layerID, 'lines', line1.id).updatedState;\n      });\n      state = Line.remove(state, layerID, lineID).updatedState;\n      return {\n        updatedState: state,\n        lines: new List([line0, line1])\n      };\n    }\n  }, {\n    key: 'addFromPoints',\n    value: function addFromPoints(state, layerID, type, points, properties, holes) {\n      var _this = this;\n\n      points = new List(points).sort(function (_ref, _ref2) {\n        var x1 = _ref.x,\n            y1 = _ref.y;\n        var x2 = _ref2.x,\n            y2 = _ref2.y;\n        return x1 === x2 ? y1 - y2 : x1 - x2;\n      });\n      var pointsPair = points.zip(points.skip(1)).filterNot(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            _ref4$ = _ref4[0],\n            x1 = _ref4$.x,\n            y1 = _ref4$.y,\n            _ref4$2 = _ref4[1],\n            x2 = _ref4$2.x,\n            y2 = _ref4$2.y;\n\n        return x1 === x2 && y1 === y2;\n      });\n      var lines = [];\n      pointsPair.forEach(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            _ref6$ = _ref6[0],\n            x1 = _ref6$.x,\n            y1 = _ref6$.y,\n            _ref6$2 = _ref6[1],\n            x2 = _ref6$2.x,\n            y2 = _ref6$2.y;\n\n        var _create = _this.create(state, layerID, type, x1, y1, x2, y2, properties),\n            stateL = _create.updatedState,\n            line = _create.line;\n\n        state = stateL;\n\n        if (holes) {\n          holes.forEach(function (holeWithOffsetPoint) {\n            var _holeWithOffsetPoint$ = holeWithOffsetPoint.offsetPosition,\n                xp = _holeWithOffsetPoint$.x,\n                yp = _holeWithOffsetPoint$.y;\n\n            if (GeometryUtils.isPointOnLineSegment(x1, y1, x2, y2, xp, yp)) {\n              var newOffset = GeometryUtils.pointPositionOnLineSegment(x1, y1, x2, y2, xp, yp);\n\n              if (newOffset >= 0 && newOffset <= 1) {\n                state = Hole.create(state, layerID, holeWithOffsetPoint.hole.type, line.id, newOffset, holeWithOffsetPoint.hole.properties).updatedState;\n              }\n            }\n          });\n        }\n\n        lines.push(line);\n      });\n      return {\n        updatedState: state,\n        lines: new List(lines)\n      };\n    }\n  }, {\n    key: 'createAvoidingIntersections',\n    value: function createAvoidingIntersections(state, layerID, type, x0, y0, x1, y1, oldProperties, oldHoles) {\n      var _this2 = this;\n\n      var points = [{\n        x: x0,\n        y: y0\n      }, {\n        x: x1,\n        y: y1\n      }];\n      state = state.getIn(['scene', 'layers', layerID, 'lines']).reduce(function (reducedState, line) {\n        var _line$vertices$map$to = line.vertices.map(function (vertexID) {\n          return reducedState.getIn(['scene', 'layers', layerID, 'vertices']).get(vertexID);\n        }).toArray(),\n            _line$vertices$map$to2 = _slicedToArray(_line$vertices$map$to, 2),\n            v0 = _line$vertices$map$to2[0],\n            v1 = _line$vertices$map$to2[1];\n\n        var hasCommonEndpoint = GeometryUtils.samePoints(v0, points[0]) || GeometryUtils.samePoints(v0, points[1]) || GeometryUtils.samePoints(v1, points[0]) || GeometryUtils.samePoints(v1, points[1]);\n        var intersection = GeometryUtils.twoLineSegmentsIntersection(points[0], points[1], v0, v1);\n\n        if (intersection.type === 'colinear') {\n          if (!oldHoles) {\n            oldHoles = [];\n          }\n\n          var orderedVertices = GeometryUtils.orderVertices(points);\n          reducedState.getIn(['scene', 'layers', layerID, 'lines', line.id, 'holes']).forEach(function (holeID) {\n            var hole = reducedState.getIn(['scene', 'layers', layerID, 'holes', holeID]);\n            var oldLineLength = GeometryUtils.pointsDistance(v0.x, v0.y, v1.x, v1.y);\n            var offset = GeometryUtils.samePoints(orderedVertices[1], line.vertices.get(1)) ? 1 - hole.offset : hole.offset;\n            var offsetPosition = GeometryUtils.extendLine(v0.x, v0.y, v1.x, v1.y, oldLineLength * offset);\n            oldHoles.push({\n              hole: hole,\n              offsetPosition: offsetPosition\n            });\n          });\n          reducedState = _this2.remove(reducedState, layerID, line.id).updatedState;\n          points.push(v0, v1);\n        }\n\n        if (intersection.type === 'intersecting' && !hasCommonEndpoint) {\n          reducedState = _this2.split(reducedState, layerID, line.id, intersection.point.x, intersection.point.y).updatedState;\n          points.push(intersection.point);\n        }\n\n        return reducedState;\n      }, state);\n\n      var _Line$addFromPoints = Line.addFromPoints(state, layerID, type, points, oldProperties, oldHoles),\n          updatedState = _Line$addFromPoints.updatedState,\n          lines = _Line$addFromPoints.lines;\n\n      return {\n        updatedState: updatedState,\n        lines: lines\n      };\n    }\n  }, {\n    key: 'replaceVertex',\n    value: function replaceVertex(state, layerID, lineID, vertexIndex, x, y) {\n      var vertexID = state.getIn(['scene', 'layers', layerID, 'lines', lineID, 'vertices', vertexIndex]);\n      state = Vertex.remove(state, layerID, vertexID, 'lines', lineID).updatedState;\n\n      var _Vertex$add3 = Vertex.add(state, layerID, x, y, 'lines', lineID),\n          stateV = _Vertex$add3.updatedState,\n          vertex = _Vertex$add3.vertex;\n\n      state = stateV;\n      state = state.setIn(['scene', 'layers', layerID, 'lines', lineID, 'vertices', vertexIndex], vertex.id);\n      state = state.setIn(['scene', 'layers', layerID, 'lines', lineID], state.getIn(['scene', 'layers', layerID, 'lines', lineID]));\n      return {\n        updatedState: state,\n        line: state.getIn(['scene', 'layers', layerID, 'lines', lineID]),\n        vertex: vertex\n      };\n    }\n  }, {\n    key: 'selectToolDrawingLine',\n    value: function selectToolDrawingLine(state, sceneComponentType) {\n      state = state.merge({\n        mode: MODE_WAITING_DRAWING_LINE,\n        drawingSupport: new Map({\n          type: sceneComponentType\n        })\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'beginDrawingLine',\n    value: function beginDrawingLine(state, layerID, x, y) {\n      var snapElements = SnapSceneUtils.sceneSnapElements(state.scene, new List(), state.snapMask);\n      var snap = null;\n\n      if (state.snapMask && !state.snapMask.isEmpty()) {\n        snap = SnapUtils.nearestSnap(snapElements, x, y, state.snapMask);\n\n        if (snap) {\n          ;\n          var _snap$point = snap.point;\n          x = _snap$point.x;\n          y = _snap$point.y;\n        }\n\n        snapElements = snapElements.withMutations(function (snapElements) {\n          var a = void 0,\n              b = void 0,\n              c = void 0;\n\n          var _GeometryUtils$horizo = GeometryUtils.horizontalLine(y);\n\n          a = _GeometryUtils$horizo.a;\n          b = _GeometryUtils$horizo.b;\n          c = _GeometryUtils$horizo.c;\n          SnapUtils.addLineSnap(snapElements, a, b, c, 10, 3, null);\n\n          var _GeometryUtils$vertic = GeometryUtils.verticalLine(x);\n\n          a = _GeometryUtils$vertic.a;\n          b = _GeometryUtils$vertic.b;\n          c = _GeometryUtils$vertic.c;\n          SnapUtils.addLineSnap(snapElements, a, b, c, 10, 3, null);\n        });\n      }\n\n      var drawingSupport = state.get('drawingSupport').set('layerID', layerID);\n      state = Layer.unselectAll(state, layerID).updatedState;\n\n      var _Line$create3 = Line.create(state, layerID, drawingSupport.get('type'), x, y, x, y),\n          stateL = _Line$create3.updatedState,\n          line = _Line$create3.line;\n\n      state = Line.select(stateL, layerID, line.id).updatedState;\n      state = state.merge({\n        mode: MODE_DRAWING_LINE,\n        snapElements: snapElements,\n        activeSnapElement: snap ? snap.snap : null,\n        drawingSupport: drawingSupport\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'updateDrawingLine',\n    value: function updateDrawingLine(state, x, y) {\n      var snap = null;\n\n      if (state.snapMask && !state.snapMask.isEmpty()) {\n        snap = SnapUtils.nearestSnap(state.snapElements, x, y, state.snapMask);\n\n        if (snap) {\n          ;\n          var _snap$point2 = snap.point;\n          x = _snap$point2.x;\n          y = _snap$point2.y;\n        }\n      }\n\n      var layerID = state.getIn(['drawingSupport', 'layerID']);\n      var lineID = state.getIn(['scene', 'layers', layerID, 'selected', 'lines']).first();\n\n      var _Line$replaceVertex = Line.replaceVertex(state, layerID, lineID, 1, x, y),\n          stateLV = _Line$replaceVertex.updatedState,\n          vertex = _Line$replaceVertex.vertex;\n\n      state = stateLV;\n      state = this.select(state, layerID, lineID).updatedState;\n      state = state.merge({\n        activeSnapElement: snap ? snap.snap : null\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'endDrawingLine',\n    value: function endDrawingLine(state, x, y) {\n      if (state.snapMask && !state.snapMask.isEmpty()) {\n        var snap = SnapUtils.nearestSnap(state.snapElements, x, y, state.snapMask);\n\n        if (snap) {\n          ;\n          var _snap$point3 = snap.point;\n          x = _snap$point3.x;\n          y = _snap$point3.y;\n        }\n      }\n\n      var layerID = state.getIn(['drawingSupport', 'layerID']);\n      var layer = state.getIn(['scene', 'layers', layerID]);\n      var lineID = state.getIn(['scene', 'layers', layerID, 'selected', 'lines']).first();\n      var line = state.getIn(['scene', 'layers', layerID, 'lines', lineID]);\n      var v0 = layer.vertices.get(line.vertices.get(0));\n      state = Line.remove(state, layerID, lineID).updatedState;\n      state = Line.createAvoidingIntersections(state, layerID, line.type, v0.x, v0.y, x, y).updatedState;\n      state = Layer.detectAndUpdateAreas(state, layerID).updatedState;\n      state = state.merge({\n        mode: MODE_WAITING_DRAWING_LINE,\n        snapElements: new List(),\n        activeSnapElement: null\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'beginDraggingLine',\n    value: function beginDraggingLine(state, layerID, lineID, x, y) {\n      var snapElements = SnapSceneUtils.sceneSnapElements(state.scene, new List(), state.snapMask);\n      var layer = state.scene.layers.get(layerID);\n      var line = layer.lines.get(lineID);\n      var vertex0 = layer.vertices.get(line.vertices.get(0));\n      var vertex1 = layer.vertices.get(line.vertices.get(1));\n      state = state.merge({\n        mode: MODE_DRAGGING_LINE,\n        snapElements: snapElements,\n        draggingSupport: Map({\n          layerID: layerID,\n          lineID: lineID,\n          startPointX: x,\n          startPointY: y,\n          startVertex0X: vertex0.x,\n          startVertex0Y: vertex0.y,\n          startVertex1X: vertex1.x,\n          startVertex1Y: vertex1.y\n        })\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'updateDraggingLine',\n    value: function updateDraggingLine(state, x, y) {\n      var draggingSupport = state.draggingSupport;\n      var snapElements = state.snapElements;\n      var layerID = draggingSupport.get('layerID');\n      var lineID = draggingSupport.get('lineID');\n      var diffX = x - draggingSupport.get('startPointX');\n      var diffY = y - draggingSupport.get('startPointY');\n      var newVertex0X = draggingSupport.get('startVertex0X') + diffX;\n      var newVertex0Y = draggingSupport.get('startVertex0Y') + diffY;\n      var newVertex1X = draggingSupport.get('startVertex1X') + diffX;\n      var newVertex1Y = draggingSupport.get('startVertex1Y') + diffY;\n      var activeSnapElement = null;\n      var curSnap0 = null,\n          curSnap1 = null;\n\n      if (state.snapMask && !state.snapMask.isEmpty()) {\n        curSnap0 = SnapUtils.nearestSnap(snapElements, newVertex0X, newVertex0Y, state.snapMask);\n        curSnap1 = SnapUtils.nearestSnap(snapElements, newVertex1X, newVertex1Y, state.snapMask);\n      }\n\n      var deltaX = 0,\n          deltaY = 0;\n\n      if (curSnap0 && curSnap1) {\n        if (curSnap0.point.distance < curSnap1.point.distance) {\n          deltaX = curSnap0.point.x - newVertex0X;\n          deltaY = curSnap0.point.y - newVertex0Y;\n          activeSnapElement = curSnap0.snap;\n        } else {\n          deltaX = curSnap1.point.x - newVertex1X;\n          deltaY = curSnap1.point.y - newVertex1Y;\n          activeSnapElement = curSnap1.snap;\n        }\n      } else {\n        if (curSnap0) {\n          deltaX = curSnap0.point.x - newVertex0X;\n          deltaY = curSnap0.point.y - newVertex0Y;\n          activeSnapElement = curSnap0.snap;\n        }\n\n        if (curSnap1) {\n          deltaX = curSnap1.point.x - newVertex1X;\n          deltaY = curSnap1.point.y - newVertex1Y;\n          activeSnapElement = curSnap1.snap;\n        }\n      }\n\n      newVertex0X += deltaX;\n      newVertex0Y += deltaY;\n      newVertex1X += deltaX;\n      newVertex1Y += deltaY;\n      state = state.merge({\n        activeSnapElement: activeSnapElement,\n        scene: state.scene.updateIn(['layers', layerID], function (layer) {\n          return layer.withMutations(function (layer) {\n            var lineVertices = layer.getIn(['lines', lineID, 'vertices']);\n            layer.updateIn(['vertices', lineVertices.get(0)], function (vertex) {\n              return vertex.merge({\n                x: newVertex0X,\n                y: newVertex0Y\n              });\n            });\n            layer.updateIn(['vertices', lineVertices.get(1)], function (vertex) {\n              return vertex.merge({\n                x: newVertex1X,\n                y: newVertex1Y\n              });\n            });\n            return layer;\n          });\n        })\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'endDraggingLine',\n    value: function endDraggingLine(state, x, y) {\n      var _state = state,\n          draggingSupport = _state.draggingSupport;\n      var layerID = draggingSupport.get('layerID');\n      var layer = state.scene.layers.get(layerID);\n      var lineID = draggingSupport.get('lineID');\n      var line = layer.lines.get(lineID);\n      var vertex0 = layer.vertices.get(line.vertices.get(0));\n      var vertex1 = layer.vertices.get(line.vertices.get(1));\n      var maxV = GeometryUtils.maxVertex(vertex0, vertex1);\n      var minV = GeometryUtils.minVertex(vertex0, vertex1);\n      var lineLength = GeometryUtils.verticesDistance(minV, maxV);\n      var alpha = Math.atan2(maxV.y - minV.y, maxV.x - minV.x);\n      var holesWithOffsetPosition = [];\n      layer.lines.get(lineID).holes.forEach(function (holeID) {\n        var hole = layer.holes.get(holeID);\n        var pointOnLine = lineLength * hole.offset;\n        var offsetPosition = {\n          x: pointOnLine * Math.cos(alpha) + minV.x,\n          y: pointOnLine * Math.sin(alpha) + minV.y\n        };\n        holesWithOffsetPosition.push({\n          hole: hole,\n          offsetPosition: offsetPosition\n        });\n      });\n      var diffX = x - draggingSupport.get('startPointX');\n      var diffY = y - draggingSupport.get('startPointY');\n      var newVertex0X = draggingSupport.get('startVertex0X') + diffX;\n      var newVertex0Y = draggingSupport.get('startVertex0Y') + diffY;\n      var newVertex1X = draggingSupport.get('startVertex1X') + diffX;\n      var newVertex1Y = draggingSupport.get('startVertex1Y') + diffY;\n\n      if (state.snapMask && !state.snapMask.isEmpty()) {\n        var curSnap0 = SnapUtils.nearestSnap(state.snapElements, newVertex0X, newVertex0Y, state.snapMask);\n        var curSnap1 = SnapUtils.nearestSnap(state.snapElements, newVertex1X, newVertex1Y, state.snapMask);\n        var deltaX = 0,\n            deltaY = 0;\n\n        if (curSnap0 && curSnap1) {\n          if (curSnap0.point.distance < curSnap1.point.distance) {\n            deltaX = curSnap0.point.x - newVertex0X;\n            deltaY = curSnap0.point.y - newVertex0Y;\n          } else {\n            deltaX = curSnap1.point.x - newVertex1X;\n            deltaY = curSnap1.point.y - newVertex1Y;\n          }\n        } else {\n          if (curSnap0) {\n            deltaX = curSnap0.point.x - newVertex0X;\n            deltaY = curSnap0.point.y - newVertex0Y;\n          }\n\n          if (curSnap1) {\n            deltaX = curSnap1.point.x - newVertex1X;\n            deltaY = curSnap1.point.y - newVertex1Y;\n          }\n        }\n\n        newVertex0X += deltaX;\n        newVertex0Y += deltaY;\n        newVertex1X += deltaX;\n        newVertex1Y += deltaY;\n      }\n\n      var lineGroups = state //get groups membership if present\n      .getIn(['scene', 'groups']).filter(function (group) {\n        var lines = group.getIn(['elements', layerID, 'lines']);\n        return lines && lines.contains(lineID);\n      });\n      state = Layer.mergeEqualsVertices(state, layerID, line.vertices.get(0)).updatedState;\n      state = Layer.mergeEqualsVertices(state, layerID, line.vertices.get(1)).updatedState;\n      state = Line.remove(state, layerID, lineID).updatedState;\n\n      if (!GeometryUtils.samePoints({\n        newVertex0X: newVertex0X,\n        newVertex0Y: newVertex0Y\n      }, {\n        newVertex1X: newVertex1X,\n        newVertex1Y: newVertex1Y\n      })) {\n        var ret = Line.createAvoidingIntersections(state, layerID, line.type, newVertex0X, newVertex0Y, newVertex1X, newVertex1Y, line.properties, holesWithOffsetPosition);\n        state = ret.updatedState; //re-add to old line's groups if present\n\n        ret.lines.forEach(function (addedLine) {\n          lineGroups.forEach(function (oldLineGroup) {\n            state = Group.addElement(state, oldLineGroup.id, layerID, 'lines', addedLine.id).updatedState;\n          });\n        });\n      }\n\n      state = Layer.detectAndUpdateAreas(state, layerID).updatedState;\n      state = state.merge({\n        mode: MODE_IDLE,\n        draggingSupport: null,\n        activeSnapElement: null,\n        snapElements: new List()\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'setProperties',\n    value: function setProperties(state, layerID, lineID, properties) {\n      state = state.mergeIn(['scene', 'layers', layerID, 'lines', lineID, 'properties'], properties);\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'setJsProperties',\n    value: function setJsProperties(state, layerID, lineID, properties) {\n      return this.setProperties(state, layerID, lineID, fromJS(properties));\n    }\n  }, {\n    key: 'updateProperties',\n    value: function updateProperties(state, layerID, lineID, properties) {\n      properties.forEach(function (v, k) {\n        if (state.hasIn(['scene', 'layers', layerID, 'lines', lineID, 'properties', k])) state = state.mergeIn(['scene', 'layers', layerID, 'lines', lineID, 'properties', k], v);\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'updateJsProperties',\n    value: function updateJsProperties(state, layerID, lineID, properties) {\n      return this.updateProperties(state, layerID, lineID, fromJS(properties));\n    }\n  }, {\n    key: 'setAttributes',\n    value: function setAttributes(state, layerID, lineID, lineAttributes) {\n      var lAttr = lineAttributes.toJS();\n      var vertexOne = lAttr.vertexOne,\n          vertexTwo = lAttr.vertexTwo,\n          lineLength = lAttr.lineLength;\n      delete lAttr['vertexOne'];\n      delete lAttr['vertexTwo'];\n      delete lAttr['lineLength'];\n      state = state.mergeIn(['scene', 'layers', layerID, 'lines', lineID], fromJS(lAttr)).mergeIn(['scene', 'layers', layerID, 'vertices', vertexOne.id], {\n        x: vertexOne.x,\n        y: vertexOne.y\n      }).mergeIn(['scene', 'layers', layerID, 'vertices', vertexTwo.id], {\n        x: vertexTwo.x,\n        y: vertexTwo.y\n      }).mergeIn(['scene', 'layers', layerID, 'lines', lineID, 'misc'], new Map({\n        '_unitLength': lineLength._unit\n      }));\n      state = Layer.mergeEqualsVertices(state, layerID, vertexOne.id).updatedState;\n\n      if (vertexOne.x != vertexTwo.x && vertexOne.y != vertexTwo.y) {\n        state = Layer.mergeEqualsVertices(state, layerID, vertexTwo.id).updatedState;\n      }\n\n      state = Layer.detectAndUpdateAreas(state, layerID).updatedState;\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'setVerticesCoords',\n    value: function setVerticesCoords(state, layerID, lineID, x1, y1, x2, y2) {\n      var line = state.getIn(['scene', 'layers', layerID, 'lines', lineID]);\n      state = Vertex.setAttributes(state, layerID, line.vertices.get(0), new Map({\n        x: x1,\n        y: y1\n      })).updatedState;\n      state = Vertex.setAttributes(state, layerID, line.vertices.get(1), new Map({\n        x: x2,\n        y: y2\n      })).updatedState;\n      return {\n        updatedState: state\n      };\n    }\n  }]);\n\n  return Line;\n}();\n\nexport { Line as default };","map":{"version":3,"sources":["/home/srihari/Desktop/Sparkplug_PandemicSparks/grid/node_modules/react-planner/es/class/line.js"],"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","Map","List","fromJS","Group","Layer","Hole","Vertex","IDBroker","NameGenerator","GeometryUtils","SnapUtils","SnapSceneUtils","MODE_IDLE","MODE_WAITING_DRAWING_LINE","MODE_DRAWING_LINE","MODE_DRAGGING_LINE","Line","create","state","layerID","type","x0","y0","x1","y1","properties","lineID","acquireID","_Vertex$add","add","stateV0","updatedState","v0","vertex","_Vertex$add2","stateV1","v1","line","catalog","factoryElement","id","name","generateName","getIn","vertices","setIn","select","selectElement","get","remove","unselect","holes","forEach","holeID","removeElement","vertexID","group","split","x","y","_Line$create","stateL1","line0","_Line$create2","stateL2","line1","splitPointOffset","pointPositionOnLineSegment","minVertex","hole","holeOffset","offset","_offset","lineGroups","filter","lines","contains","addElement","addFromPoints","points","_this","sort","_ref","_ref2","x2","y2","pointsPair","zip","skip","filterNot","_ref3","_ref4","_ref4$","_ref4$2","_ref5","_ref6","_ref6$","_ref6$2","_create","stateL","holeWithOffsetPoint","_holeWithOffsetPoint$","offsetPosition","xp","yp","isPointOnLineSegment","newOffset","createAvoidingIntersections","oldProperties","oldHoles","_this2","reduce","reducedState","_line$vertices$map$to","map","toArray","_line$vertices$map$to2","hasCommonEndpoint","samePoints","intersection","twoLineSegmentsIntersection","orderedVertices","orderVertices","oldLineLength","pointsDistance","extendLine","point","_Line$addFromPoints","replaceVertex","vertexIndex","_Vertex$add3","stateV","selectToolDrawingLine","sceneComponentType","merge","mode","drawingSupport","beginDrawingLine","snapElements","sceneSnapElements","scene","snapMask","snap","isEmpty","nearestSnap","_snap$point","withMutations","a","b","c","_GeometryUtils$horizo","horizontalLine","addLineSnap","_GeometryUtils$vertic","verticalLine","set","unselectAll","_Line$create3","activeSnapElement","updateDrawingLine","_snap$point2","first","_Line$replaceVertex","stateLV","endDrawingLine","_snap$point3","layer","detectAndUpdateAreas","beginDraggingLine","layers","vertex0","vertex1","draggingSupport","startPointX","startPointY","startVertex0X","startVertex0Y","startVertex1X","startVertex1Y","updateDraggingLine","diffX","diffY","newVertex0X","newVertex0Y","newVertex1X","newVertex1Y","curSnap0","curSnap1","deltaX","deltaY","distance","updateIn","lineVertices","endDraggingLine","_state","maxV","maxVertex","minV","lineLength","verticesDistance","alpha","Math","atan2","holesWithOffsetPosition","pointOnLine","cos","sin","mergeEqualsVertices","ret","addedLine","oldLineGroup","setProperties","mergeIn","setJsProperties","updateProperties","v","k","hasIn","updateJsProperties","setAttributes","lineAttributes","lAttr","toJS","vertexOne","vertexTwo","_unit","setVerticesCoords","default"],"mappings":"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","sourcesContent":["var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nimport { Map, List, fromJS } from 'immutable';\nimport { Group, Layer, Hole, Vertex } from './export';\nimport { IDBroker, NameGenerator, GeometryUtils, SnapUtils, SnapSceneUtils } from '../utils/export';\nimport { MODE_IDLE, MODE_WAITING_DRAWING_LINE, MODE_DRAWING_LINE, MODE_DRAGGING_LINE } from '../constants';\n\nvar Line = function () {\n  function Line() {\n    _classCallCheck(this, Line);\n  }\n\n  _createClass(Line, null, [{\n    key: 'create',\n    value: function create(state, layerID, type, x0, y0, x1, y1, properties) {\n\n      var lineID = IDBroker.acquireID();\n\n      var _Vertex$add = Vertex.add(state, layerID, x0, y0, 'lines', lineID),\n          stateV0 = _Vertex$add.updatedState,\n          v0 = _Vertex$add.vertex;\n\n      var _Vertex$add2 = Vertex.add(stateV0, layerID, x1, y1, 'lines', lineID),\n          stateV1 = _Vertex$add2.updatedState,\n          v1 = _Vertex$add2.vertex;\n\n      state = stateV1;\n\n      var line = state.catalog.factoryElement(type, {\n        id: lineID,\n        name: NameGenerator.generateName('lines', state.catalog.getIn(['elements', type, 'info', 'title'])),\n        vertices: new List([v0.id, v1.id]),\n        type: type\n      }, properties);\n\n      state = state.setIn(['scene', 'layers', layerID, 'lines', lineID], line);\n\n      return { updatedState: state, line: line };\n    }\n  }, {\n    key: 'select',\n    value: function select(state, layerID, lineID) {\n      state = Layer.select(state, layerID).updatedState;\n\n      var line = state.getIn(['scene', 'layers', layerID, 'lines', lineID]);\n\n      state = Layer.selectElement(state, layerID, 'lines', lineID).updatedState;\n      state = Layer.selectElement(state, layerID, 'vertices', line.vertices.get(0)).updatedState;\n      state = Layer.selectElement(state, layerID, 'vertices', line.vertices.get(1)).updatedState;\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'remove',\n    value: function remove(state, layerID, lineID) {\n      var line = state.getIn(['scene', 'layers', layerID, 'lines', lineID]);\n\n      if (line) {\n        state = this.unselect(state, layerID, lineID).updatedState;\n        line.holes.forEach(function (holeID) {\n          return state = Hole.remove(state, layerID, holeID).updatedState;\n        });\n        state = Layer.removeElement(state, layerID, 'lines', lineID).updatedState;\n\n        line.vertices.forEach(function (vertexID) {\n          return state = Vertex.remove(state, layerID, vertexID, 'lines', lineID).updatedState;\n        });\n\n        state.getIn(['scene', 'groups']).forEach(function (group) {\n          return state = Group.removeElement(state, group.id, layerID, 'lines', lineID).updatedState;\n        });\n      }\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'unselect',\n    value: function unselect(state, layerID, lineID) {\n      var line = state.getIn(['scene', 'layers', layerID, 'lines', lineID]);\n\n      if (line) {\n        state = Layer.unselect(state, layerID, 'vertices', line.vertices.get(0)).updatedState;\n        state = Layer.unselect(state, layerID, 'vertices', line.vertices.get(1)).updatedState;\n        state = Layer.unselect(state, layerID, 'lines', lineID).updatedState;\n      }\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'split',\n    value: function split(state, layerID, lineID, x, y) {\n      var line = state.getIn(['scene', 'layers', layerID, 'lines', lineID]);\n      var v0 = state.getIn(['scene', 'layers', layerID, 'vertices', line.vertices.get(0)]);\n      var v1 = state.getIn(['scene', 'layers', layerID, 'vertices', line.vertices.get(1)]);\n      var x0 = v0.x,\n          y0 = v0.y;\n      var x1 = v1.x,\n          y1 = v1.y;\n\n      var _Line$create = Line.create(state, layerID, line.type, x0, y0, x, y, line.get('properties')),\n          stateL1 = _Line$create.updatedState,\n          line0 = _Line$create.line;\n\n      var _Line$create2 = Line.create(stateL1, layerID, line.type, x1, y1, x, y, line.get('properties')),\n          stateL2 = _Line$create2.updatedState,\n          line1 = _Line$create2.line;\n\n      state = stateL2;\n\n      var splitPointOffset = GeometryUtils.pointPositionOnLineSegment(x0, y0, x1, y1, x, y);\n      var minVertex = GeometryUtils.minVertex(v0, v1);\n\n      line.holes.forEach(function (holeID) {\n        var hole = state.getIn(['scene', 'layers', layerID, 'holes', holeID]);\n\n        var holeOffset = hole.offset;\n        if (minVertex.x === x1 && minVertex.y === y1) {\n          splitPointOffset = 1 - splitPointOffset;\n          holeOffset = 1 - hole.offset;\n        }\n\n        if (holeOffset < splitPointOffset) {\n          var offset = holeOffset / splitPointOffset;\n          if (minVertex.x === x1 && minVertex.y === y1) {\n            offset = 1 - offset;\n          }\n          state = Hole.create(state, layerID, hole.type, line0.id, offset, hole.properties).updatedState;\n        } else {\n          var _offset = (holeOffset - splitPointOffset) / (1 - splitPointOffset);\n          if (minVertex.x === x1 && minVertex.y === y1) {\n            _offset = 1 - _offset;\n          }\n          state = Hole.create(state, layerID, hole.type, line1.id, _offset, hole.properties).updatedState;\n        }\n      });\n\n      //add splitted lines to the original line's group\n      var lineGroups = state.getIn(['scene', 'groups']).filter(function (group) {\n        var lines = group.getIn(['elements', layerID, 'lines']);\n        return lines && lines.contains(lineID);\n      });\n\n      lineGroups.forEach(function (group) {\n        state = Group.addElement(state, group.id, layerID, 'lines', line0.id).updatedState;\n        state = Group.addElement(state, group.id, layerID, 'lines', line1.id).updatedState;\n      });\n\n      state = Line.remove(state, layerID, lineID).updatedState;\n\n      return { updatedState: state, lines: new List([line0, line1]) };\n    }\n  }, {\n    key: 'addFromPoints',\n    value: function addFromPoints(state, layerID, type, points, properties, holes) {\n      var _this = this;\n\n      points = new List(points).sort(function (_ref, _ref2) {\n        var x1 = _ref.x,\n            y1 = _ref.y;\n        var x2 = _ref2.x,\n            y2 = _ref2.y;\n        return x1 === x2 ? y1 - y2 : x1 - x2;\n      });\n\n      var pointsPair = points.zip(points.skip(1)).filterNot(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            _ref4$ = _ref4[0],\n            x1 = _ref4$.x,\n            y1 = _ref4$.y,\n            _ref4$2 = _ref4[1],\n            x2 = _ref4$2.x,\n            y2 = _ref4$2.y;\n\n        return x1 === x2 && y1 === y2;\n      });\n\n      var lines = [];\n\n      pointsPair.forEach(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            _ref6$ = _ref6[0],\n            x1 = _ref6$.x,\n            y1 = _ref6$.y,\n            _ref6$2 = _ref6[1],\n            x2 = _ref6$2.x,\n            y2 = _ref6$2.y;\n\n        var _create = _this.create(state, layerID, type, x1, y1, x2, y2, properties),\n            stateL = _create.updatedState,\n            line = _create.line;\n\n        state = stateL;\n\n        if (holes) {\n          holes.forEach(function (holeWithOffsetPoint) {\n            var _holeWithOffsetPoint$ = holeWithOffsetPoint.offsetPosition,\n                xp = _holeWithOffsetPoint$.x,\n                yp = _holeWithOffsetPoint$.y;\n\n\n            if (GeometryUtils.isPointOnLineSegment(x1, y1, x2, y2, xp, yp)) {\n\n              var newOffset = GeometryUtils.pointPositionOnLineSegment(x1, y1, x2, y2, xp, yp);\n\n              if (newOffset >= 0 && newOffset <= 1) {\n                state = Hole.create(state, layerID, holeWithOffsetPoint.hole.type, line.id, newOffset, holeWithOffsetPoint.hole.properties).updatedState;\n              }\n            }\n          });\n        }\n\n        lines.push(line);\n      });\n\n      return { updatedState: state, lines: new List(lines) };\n    }\n  }, {\n    key: 'createAvoidingIntersections',\n    value: function createAvoidingIntersections(state, layerID, type, x0, y0, x1, y1, oldProperties, oldHoles) {\n      var _this2 = this;\n\n      var points = [{ x: x0, y: y0 }, { x: x1, y: y1 }];\n\n      state = state.getIn(['scene', 'layers', layerID, 'lines']).reduce(function (reducedState, line) {\n        var _line$vertices$map$to = line.vertices.map(function (vertexID) {\n          return reducedState.getIn(['scene', 'layers', layerID, 'vertices']).get(vertexID);\n        }).toArray(),\n            _line$vertices$map$to2 = _slicedToArray(_line$vertices$map$to, 2),\n            v0 = _line$vertices$map$to2[0],\n            v1 = _line$vertices$map$to2[1];\n\n        var hasCommonEndpoint = GeometryUtils.samePoints(v0, points[0]) || GeometryUtils.samePoints(v0, points[1]) || GeometryUtils.samePoints(v1, points[0]) || GeometryUtils.samePoints(v1, points[1]);\n\n        var intersection = GeometryUtils.twoLineSegmentsIntersection(points[0], points[1], v0, v1);\n\n        if (intersection.type === 'colinear') {\n          if (!oldHoles) {\n            oldHoles = [];\n          }\n\n          var orderedVertices = GeometryUtils.orderVertices(points);\n\n          reducedState.getIn(['scene', 'layers', layerID, 'lines', line.id, 'holes']).forEach(function (holeID) {\n            var hole = reducedState.getIn(['scene', 'layers', layerID, 'holes', holeID]);\n            var oldLineLength = GeometryUtils.pointsDistance(v0.x, v0.y, v1.x, v1.y);\n            var offset = GeometryUtils.samePoints(orderedVertices[1], line.vertices.get(1)) ? 1 - hole.offset : hole.offset;\n            var offsetPosition = GeometryUtils.extendLine(v0.x, v0.y, v1.x, v1.y, oldLineLength * offset);\n\n            oldHoles.push({ hole: hole, offsetPosition: offsetPosition });\n          });\n\n          reducedState = _this2.remove(reducedState, layerID, line.id).updatedState;\n\n          points.push(v0, v1);\n        }\n\n        if (intersection.type === 'intersecting' && !hasCommonEndpoint) {\n          reducedState = _this2.split(reducedState, layerID, line.id, intersection.point.x, intersection.point.y).updatedState;\n          points.push(intersection.point);\n        }\n\n        return reducedState;\n      }, state);\n\n      var _Line$addFromPoints = Line.addFromPoints(state, layerID, type, points, oldProperties, oldHoles),\n          updatedState = _Line$addFromPoints.updatedState,\n          lines = _Line$addFromPoints.lines;\n\n      return { updatedState: updatedState, lines: lines };\n    }\n  }, {\n    key: 'replaceVertex',\n    value: function replaceVertex(state, layerID, lineID, vertexIndex, x, y) {\n      var vertexID = state.getIn(['scene', 'layers', layerID, 'lines', lineID, 'vertices', vertexIndex]);\n\n      state = Vertex.remove(state, layerID, vertexID, 'lines', lineID).updatedState;\n\n      var _Vertex$add3 = Vertex.add(state, layerID, x, y, 'lines', lineID),\n          stateV = _Vertex$add3.updatedState,\n          vertex = _Vertex$add3.vertex;\n\n      state = stateV;\n\n      state = state.setIn(['scene', 'layers', layerID, 'lines', lineID, 'vertices', vertexIndex], vertex.id);\n      state = state.setIn(['scene', 'layers', layerID, 'lines', lineID], state.getIn(['scene', 'layers', layerID, 'lines', lineID]));\n\n      return { updatedState: state, line: state.getIn(['scene', 'layers', layerID, 'lines', lineID]), vertex: vertex };\n    }\n  }, {\n    key: 'selectToolDrawingLine',\n    value: function selectToolDrawingLine(state, sceneComponentType) {\n      state = state.merge({\n        mode: MODE_WAITING_DRAWING_LINE,\n        drawingSupport: new Map({\n          type: sceneComponentType\n        })\n      });\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'beginDrawingLine',\n    value: function beginDrawingLine(state, layerID, x, y) {\n      var snapElements = SnapSceneUtils.sceneSnapElements(state.scene, new List(), state.snapMask);\n      var snap = null;\n\n      if (state.snapMask && !state.snapMask.isEmpty()) {\n        snap = SnapUtils.nearestSnap(snapElements, x, y, state.snapMask);\n        if (snap) {\n          ;\n\n          var _snap$point = snap.point;\n          x = _snap$point.x;\n          y = _snap$point.y;\n        }snapElements = snapElements.withMutations(function (snapElements) {\n          var a = void 0,\n              b = void 0,\n              c = void 0;\n\n          var _GeometryUtils$horizo = GeometryUtils.horizontalLine(y);\n\n          a = _GeometryUtils$horizo.a;\n          b = _GeometryUtils$horizo.b;\n          c = _GeometryUtils$horizo.c;\n\n          SnapUtils.addLineSnap(snapElements, a, b, c, 10, 3, null);\n\n          var _GeometryUtils$vertic = GeometryUtils.verticalLine(x);\n\n          a = _GeometryUtils$vertic.a;\n          b = _GeometryUtils$vertic.b;\n          c = _GeometryUtils$vertic.c;\n\n          SnapUtils.addLineSnap(snapElements, a, b, c, 10, 3, null);\n        });\n      }\n\n      var drawingSupport = state.get('drawingSupport').set('layerID', layerID);\n\n      state = Layer.unselectAll(state, layerID).updatedState;\n\n      var _Line$create3 = Line.create(state, layerID, drawingSupport.get('type'), x, y, x, y),\n          stateL = _Line$create3.updatedState,\n          line = _Line$create3.line;\n\n      state = Line.select(stateL, layerID, line.id).updatedState;\n\n      state = state.merge({\n        mode: MODE_DRAWING_LINE,\n        snapElements: snapElements,\n        activeSnapElement: snap ? snap.snap : null,\n        drawingSupport: drawingSupport\n      });\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'updateDrawingLine',\n    value: function updateDrawingLine(state, x, y) {\n      var snap = null;\n      if (state.snapMask && !state.snapMask.isEmpty()) {\n        snap = SnapUtils.nearestSnap(state.snapElements, x, y, state.snapMask);\n        if (snap) {\n          ;\n          var _snap$point2 = snap.point;\n          x = _snap$point2.x;\n          y = _snap$point2.y;\n        }\n      }\n\n      var layerID = state.getIn(['drawingSupport', 'layerID']);\n      var lineID = state.getIn(['scene', 'layers', layerID, 'selected', 'lines']).first();\n\n      var _Line$replaceVertex = Line.replaceVertex(state, layerID, lineID, 1, x, y),\n          stateLV = _Line$replaceVertex.updatedState,\n          vertex = _Line$replaceVertex.vertex;\n\n      state = stateLV;\n\n      state = this.select(state, layerID, lineID).updatedState;\n      state = state.merge({ activeSnapElement: snap ? snap.snap : null });\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'endDrawingLine',\n    value: function endDrawingLine(state, x, y) {\n\n      if (state.snapMask && !state.snapMask.isEmpty()) {\n        var snap = SnapUtils.nearestSnap(state.snapElements, x, y, state.snapMask);\n        if (snap) {\n          ;\n          var _snap$point3 = snap.point;\n          x = _snap$point3.x;\n          y = _snap$point3.y;\n        }\n      }\n\n      var layerID = state.getIn(['drawingSupport', 'layerID']);\n      var layer = state.getIn(['scene', 'layers', layerID]);\n\n      var lineID = state.getIn(['scene', 'layers', layerID, 'selected', 'lines']).first();\n      var line = state.getIn(['scene', 'layers', layerID, 'lines', lineID]);\n\n      var v0 = layer.vertices.get(line.vertices.get(0));\n\n      state = Line.remove(state, layerID, lineID).updatedState;\n      state = Line.createAvoidingIntersections(state, layerID, line.type, v0.x, v0.y, x, y).updatedState;\n      state = Layer.detectAndUpdateAreas(state, layerID).updatedState;\n\n      state = state.merge({\n        mode: MODE_WAITING_DRAWING_LINE,\n        snapElements: new List(),\n        activeSnapElement: null\n      });\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'beginDraggingLine',\n    value: function beginDraggingLine(state, layerID, lineID, x, y) {\n\n      var snapElements = SnapSceneUtils.sceneSnapElements(state.scene, new List(), state.snapMask);\n\n      var layer = state.scene.layers.get(layerID);\n      var line = layer.lines.get(lineID);\n\n      var vertex0 = layer.vertices.get(line.vertices.get(0));\n      var vertex1 = layer.vertices.get(line.vertices.get(1));\n\n      state = state.merge({\n        mode: MODE_DRAGGING_LINE,\n        snapElements: snapElements,\n        draggingSupport: Map({\n          layerID: layerID, lineID: lineID,\n          startPointX: x,\n          startPointY: y,\n          startVertex0X: vertex0.x,\n          startVertex0Y: vertex0.y,\n          startVertex1X: vertex1.x,\n          startVertex1Y: vertex1.y\n        })\n      });\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'updateDraggingLine',\n    value: function updateDraggingLine(state, x, y) {\n\n      var draggingSupport = state.draggingSupport;\n      var snapElements = state.snapElements;\n\n      var layerID = draggingSupport.get('layerID');\n      var lineID = draggingSupport.get('lineID');\n      var diffX = x - draggingSupport.get('startPointX');\n      var diffY = y - draggingSupport.get('startPointY');\n      var newVertex0X = draggingSupport.get('startVertex0X') + diffX;\n      var newVertex0Y = draggingSupport.get('startVertex0Y') + diffY;\n      var newVertex1X = draggingSupport.get('startVertex1X') + diffX;\n      var newVertex1Y = draggingSupport.get('startVertex1Y') + diffY;\n\n      var activeSnapElement = null;\n      var curSnap0 = null,\n          curSnap1 = null;\n      if (state.snapMask && !state.snapMask.isEmpty()) {\n        curSnap0 = SnapUtils.nearestSnap(snapElements, newVertex0X, newVertex0Y, state.snapMask);\n        curSnap1 = SnapUtils.nearestSnap(snapElements, newVertex1X, newVertex1Y, state.snapMask);\n      }\n\n      var deltaX = 0,\n          deltaY = 0;\n      if (curSnap0 && curSnap1) {\n        if (curSnap0.point.distance < curSnap1.point.distance) {\n          deltaX = curSnap0.point.x - newVertex0X;\n          deltaY = curSnap0.point.y - newVertex0Y;\n          activeSnapElement = curSnap0.snap;\n        } else {\n          deltaX = curSnap1.point.x - newVertex1X;\n          deltaY = curSnap1.point.y - newVertex1Y;\n          activeSnapElement = curSnap1.snap;\n        }\n      } else {\n        if (curSnap0) {\n          deltaX = curSnap0.point.x - newVertex0X;\n          deltaY = curSnap0.point.y - newVertex0Y;\n          activeSnapElement = curSnap0.snap;\n        }\n        if (curSnap1) {\n          deltaX = curSnap1.point.x - newVertex1X;\n          deltaY = curSnap1.point.y - newVertex1Y;\n          activeSnapElement = curSnap1.snap;\n        }\n      }\n\n      newVertex0X += deltaX;\n      newVertex0Y += deltaY;\n      newVertex1X += deltaX;\n      newVertex1Y += deltaY;\n\n      state = state.merge({\n        activeSnapElement: activeSnapElement,\n        scene: state.scene.updateIn(['layers', layerID], function (layer) {\n          return layer.withMutations(function (layer) {\n            var lineVertices = layer.getIn(['lines', lineID, 'vertices']);\n            layer.updateIn(['vertices', lineVertices.get(0)], function (vertex) {\n              return vertex.merge({ x: newVertex0X, y: newVertex0Y });\n            });\n            layer.updateIn(['vertices', lineVertices.get(1)], function (vertex) {\n              return vertex.merge({ x: newVertex1X, y: newVertex1Y });\n            });\n            return layer;\n          });\n        })\n      });\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'endDraggingLine',\n    value: function endDraggingLine(state, x, y) {\n      var _state = state,\n          draggingSupport = _state.draggingSupport;\n\n      var layerID = draggingSupport.get('layerID');\n      var layer = state.scene.layers.get(layerID);\n      var lineID = draggingSupport.get('lineID');\n      var line = layer.lines.get(lineID);\n\n      var vertex0 = layer.vertices.get(line.vertices.get(0));\n      var vertex1 = layer.vertices.get(line.vertices.get(1));\n\n      var maxV = GeometryUtils.maxVertex(vertex0, vertex1);\n      var minV = GeometryUtils.minVertex(vertex0, vertex1);\n\n      var lineLength = GeometryUtils.verticesDistance(minV, maxV);\n      var alpha = Math.atan2(maxV.y - minV.y, maxV.x - minV.x);\n\n      var holesWithOffsetPosition = [];\n      layer.lines.get(lineID).holes.forEach(function (holeID) {\n        var hole = layer.holes.get(holeID);\n        var pointOnLine = lineLength * hole.offset;\n\n        var offsetPosition = {\n          x: pointOnLine * Math.cos(alpha) + minV.x,\n          y: pointOnLine * Math.sin(alpha) + minV.y\n        };\n\n        holesWithOffsetPosition.push({ hole: hole, offsetPosition: offsetPosition });\n      });\n\n      var diffX = x - draggingSupport.get('startPointX');\n      var diffY = y - draggingSupport.get('startPointY');\n      var newVertex0X = draggingSupport.get('startVertex0X') + diffX;\n      var newVertex0Y = draggingSupport.get('startVertex0Y') + diffY;\n      var newVertex1X = draggingSupport.get('startVertex1X') + diffX;\n      var newVertex1Y = draggingSupport.get('startVertex1Y') + diffY;\n\n      if (state.snapMask && !state.snapMask.isEmpty()) {\n\n        var curSnap0 = SnapUtils.nearestSnap(state.snapElements, newVertex0X, newVertex0Y, state.snapMask);\n        var curSnap1 = SnapUtils.nearestSnap(state.snapElements, newVertex1X, newVertex1Y, state.snapMask);\n\n        var deltaX = 0,\n            deltaY = 0;\n        if (curSnap0 && curSnap1) {\n          if (curSnap0.point.distance < curSnap1.point.distance) {\n            deltaX = curSnap0.point.x - newVertex0X;\n            deltaY = curSnap0.point.y - newVertex0Y;\n          } else {\n            deltaX = curSnap1.point.x - newVertex1X;\n            deltaY = curSnap1.point.y - newVertex1Y;\n          }\n        } else {\n          if (curSnap0) {\n            deltaX = curSnap0.point.x - newVertex0X;\n            deltaY = curSnap0.point.y - newVertex0Y;\n          }\n          if (curSnap1) {\n            deltaX = curSnap1.point.x - newVertex1X;\n            deltaY = curSnap1.point.y - newVertex1Y;\n          }\n        }\n\n        newVertex0X += deltaX;\n        newVertex0Y += deltaY;\n        newVertex1X += deltaX;\n        newVertex1Y += deltaY;\n      }\n\n      var lineGroups = state //get groups membership if present\n      .getIn(['scene', 'groups']).filter(function (group) {\n        var lines = group.getIn(['elements', layerID, 'lines']);\n        return lines && lines.contains(lineID);\n      });\n\n      state = Layer.mergeEqualsVertices(state, layerID, line.vertices.get(0)).updatedState;\n      state = Layer.mergeEqualsVertices(state, layerID, line.vertices.get(1)).updatedState;\n\n      state = Line.remove(state, layerID, lineID).updatedState;\n\n      if (!GeometryUtils.samePoints({ newVertex0X: newVertex0X, newVertex0Y: newVertex0Y }, { newVertex1X: newVertex1X, newVertex1Y: newVertex1Y })) {\n        var ret = Line.createAvoidingIntersections(state, layerID, line.type, newVertex0X, newVertex0Y, newVertex1X, newVertex1Y, line.properties, holesWithOffsetPosition);\n\n        state = ret.updatedState;\n\n        //re-add to old line's groups if present\n        ret.lines.forEach(function (addedLine) {\n          lineGroups.forEach(function (oldLineGroup) {\n            state = Group.addElement(state, oldLineGroup.id, layerID, 'lines', addedLine.id).updatedState;\n          });\n        });\n      }\n\n      state = Layer.detectAndUpdateAreas(state, layerID).updatedState;\n\n      state = state.merge({\n        mode: MODE_IDLE,\n        draggingSupport: null,\n        activeSnapElement: null,\n        snapElements: new List()\n      });\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'setProperties',\n    value: function setProperties(state, layerID, lineID, properties) {\n      state = state.mergeIn(['scene', 'layers', layerID, 'lines', lineID, 'properties'], properties);\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'setJsProperties',\n    value: function setJsProperties(state, layerID, lineID, properties) {\n      return this.setProperties(state, layerID, lineID, fromJS(properties));\n    }\n  }, {\n    key: 'updateProperties',\n    value: function updateProperties(state, layerID, lineID, properties) {\n      properties.forEach(function (v, k) {\n        if (state.hasIn(['scene', 'layers', layerID, 'lines', lineID, 'properties', k])) state = state.mergeIn(['scene', 'layers', layerID, 'lines', lineID, 'properties', k], v);\n      });\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'updateJsProperties',\n    value: function updateJsProperties(state, layerID, lineID, properties) {\n      return this.updateProperties(state, layerID, lineID, fromJS(properties));\n    }\n  }, {\n    key: 'setAttributes',\n    value: function setAttributes(state, layerID, lineID, lineAttributes) {\n\n      var lAttr = lineAttributes.toJS();\n      var vertexOne = lAttr.vertexOne,\n          vertexTwo = lAttr.vertexTwo,\n          lineLength = lAttr.lineLength;\n\n\n      delete lAttr['vertexOne'];\n      delete lAttr['vertexTwo'];\n      delete lAttr['lineLength'];\n\n      state = state.mergeIn(['scene', 'layers', layerID, 'lines', lineID], fromJS(lAttr)).mergeIn(['scene', 'layers', layerID, 'vertices', vertexOne.id], { x: vertexOne.x, y: vertexOne.y }).mergeIn(['scene', 'layers', layerID, 'vertices', vertexTwo.id], { x: vertexTwo.x, y: vertexTwo.y }).mergeIn(['scene', 'layers', layerID, 'lines', lineID, 'misc'], new Map({ '_unitLength': lineLength._unit }));\n\n      state = Layer.mergeEqualsVertices(state, layerID, vertexOne.id).updatedState;\n\n      if (vertexOne.x != vertexTwo.x && vertexOne.y != vertexTwo.y) {\n        state = Layer.mergeEqualsVertices(state, layerID, vertexTwo.id).updatedState;\n      }\n\n      state = Layer.detectAndUpdateAreas(state, layerID).updatedState;\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'setVerticesCoords',\n    value: function setVerticesCoords(state, layerID, lineID, x1, y1, x2, y2) {\n      var line = state.getIn(['scene', 'layers', layerID, 'lines', lineID]);\n      state = Vertex.setAttributes(state, layerID, line.vertices.get(0), new Map({ x: x1, y: y1 })).updatedState;\n      state = Vertex.setAttributes(state, layerID, line.vertices.get(1), new Map({ x: x2, y: y2 })).updatedState;\n\n      return { updatedState: state };\n    }\n  }]);\n\n  return Line;\n}();\n\nexport { Line as default };"]},"metadata":{},"sourceType":"module"}