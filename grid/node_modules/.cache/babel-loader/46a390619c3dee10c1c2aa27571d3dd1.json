{"ast":null,"code":"/**\n * UTILS\n */\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\nfunction mod(n, m) {\n  return (n % m + m) % m;\n}\n/**\n * CYCLES\n */\n\n\nfunction compute_ev_mapping(EV) {\n  var ev_mapping = EV.map(function (ev) {\n    return {\n      ev: ev,\n      color: 0,\n      direction: -1\n    };\n  });\n  return ev_mapping;\n}\n\nfunction compute_angle(P, V) {\n  var point = sub(V, P);\n  var angle = Math.atan2(point[1], point[0]);\n  return angle;\n}\n\nfunction compute_incidences(V, EV) {\n  var incidences = V.map(function (vertex, i) {\n    var incidence = [];\n    EV.forEach(function (edge, j) {\n      var endpoint = void 0;\n      var position = void 0;\n\n      if (edge[0] === i) {\n        endpoint = edge[1];\n        position = 1;\n      }\n\n      if (edge[1] === i) {\n        endpoint = edge[0];\n        position = 0;\n      }\n\n      endpoint !== undefined && incidence.push({\n        index: j,\n        endpoint: endpoint,\n        angle: compute_angle(vertex, V[endpoint]),\n        edge: edge,\n        position: position\n      });\n    });\n    incidence.sort(function (i1, i2) {\n      return i2.angle - i1.angle;\n    });\n    return incidence;\n  });\n  return incidences;\n}\n\nfunction get_starting_edge(incidences, ev_mapping) {\n  var e = void 0;\n  var position = void 0;\n  var direction = void 0;\n\n  for (e = 0; e < ev_mapping.length; e += 1) {\n    if (ev_mapping[e].color < 2) {\n      direction = -1 * ev_mapping[e].direction;\n      color(ev_mapping, e, direction);\n      return {\n        edge: e,\n        direction: direction,\n        position: direction === -1 ? 0 : 1\n      };\n    }\n  }\n}\n\nfunction get_next_edge(incidences, edge, position, EV) {\n  var items = incidences[EV[edge][position]]; //console.log(items, incidences, EV, edge, position);\n\n  var n_items = items.length;\n  var item = void 0;\n  var out = void 0;\n  var j = void 0;\n\n  for (j = 0; j < n_items; j += 1) {\n    item = items[j];\n\n    if (item.index === edge) {\n      out = items[mod(j + 1, items.length)];\n      return {\n        edge: out.index,\n        vertex: out.endpoint,\n        position: out.position,\n        direction: out.position ? 1 : -1\n      };\n    }\n  }\n}\n\nfunction color(ev_mapping, index, direction) {\n  ev_mapping[index].color += 1;\n  ev_mapping[index].direction = direction;\n}\n\nfunction find_cycles(V, EV) {\n  var ev_mapping = compute_ev_mapping(EV);\n  var incidences = compute_incidences(V, EV);\n  var V_cycles = [];\n  var E_cycles = [];\n  var dir_E_cycles = [];\n  var V_cycle = void 0;\n  var E_cycle = void 0;\n  var dir_E_cycle = void 0;\n  var next = void 0;\n  var counter = 0;\n  var start = get_starting_edge(incidences, ev_mapping);\n\n  while (start !== undefined) {\n    V_cycle = [EV[start.edge][mod(start.position + 1, 2)], EV[start.edge][start.position]];\n    E_cycle = [start.edge];\n    dir_E_cycle = [start.direction];\n    next = get_next_edge(incidences, start.edge, start.position, EV);\n\n    while (next.edge !== start.edge) {\n      V_cycle.push(next.vertex);\n      E_cycle.push(next.edge);\n      dir_E_cycle.push(next.direction);\n      color(ev_mapping, next.edge, next.direction);\n      next = get_next_edge(incidences, next.edge, next.position, EV);\n    }\n\n    E_cycles.push(E_cycle);\n    V_cycles.push(V_cycle);\n    dir_E_cycles.push(dir_E_cycle); //console.log('############## CYCLE ', ++counter)\n    //console.log('EDGES:', E_cycle)\n    //console.log('VERTICES:', V_cycle)\n    //console.log('START', 'edge:', start.edge, 'position:', start.position)\n    //console.log('COUNTER:', ev_mapping.map(e => e.color), ev_mapping.map(e => e.color).reduce((a, b) => a + b));\n    //console.log('\\n')\n\n    start = get_starting_edge(incidences, ev_mapping);\n  }\n\n  return {\n    v_cycles: V_cycles,\n    e_cycles: E_cycles,\n    dir_e_cycles: dir_E_cycles,\n    ev_mapping: ev_mapping\n  };\n}\n\nfunction find_short_cycles_indexes(v_cycles, e_cycles) {\n  var indexes = [];\n  var e_cycle = void 0;\n  var v_cycle = void 0;\n  var i = void 0;\n\n  for (i = 0; i < e_cycles.length; i += 1) {\n    e_cycle = e_cycles[i];\n    v_cycle = v_cycles[i];\n\n    if (e_cycle.length < 3 || v_cycle[0] !== v_cycle[v_cycle.length - 1]) {\n      indexes.push(i);\n    }\n  }\n\n  return indexes;\n}\n\nfunction find_inner_cycles(V, EV) {\n  var cycles = find_cycles(V, EV);\n  var v_cycles = cycles.v_cycles;\n  var e_cycles = cycles.e_cycles;\n  var short_cycles_indexes = find_short_cycles_indexes(v_cycles, e_cycles);\n  short_cycles_indexes.forEach(function (indx) {\n    v_cycles.splice(indx, 1);\n    e_cycles.splice(indx, 1);\n  });\n  var dir_e_cycles = cycles.dir_e_cycles;\n  var rooms_values = cycles.e_cycles.map(function (cycle, i) {\n    return cycle.map(function (edge, j) {\n      var v1 = void 0;\n      var v2 = void 0;\n      var dir = dir_e_cycles[i][j] > 0;\n\n      if (dir > 0) {\n        v1 = EV[edge][0];\n        v2 = EV[edge][1];\n      } else {\n        v1 = EV[edge][1];\n        v2 = EV[edge][0];\n      }\n\n      return (V[v2][0] - V[v1][0]) * (V[v2][1] + V[v1][1]);\n    });\n  });\n  var rooms_sums = rooms_values.map(function (room) {\n    return room.reduce(function (a, b) {\n      return a + b;\n    });\n  });\n  var positive_count = rooms_sums.filter(function (sum) {\n    return sum > 0;\n  }).length;\n  var negative_count = rooms_sums.length - positive_count;\n  var rm_neg = positive_count >= negative_count ? 1 : -1;\n  return {\n    v_cycles: cycles.v_cycles.filter(function (v, i) {\n      return rm_neg * rooms_sums[i] > 0;\n    }),\n    e_cycles: cycles.e_cycles.filter(function (v, i) {\n      return rm_neg * rooms_sums[i] > 0;\n    }),\n    ev_mapping: cycles.ev_mapping\n  };\n} // export default find_inner_cycles;\n\n\nmodule.exports = find_inner_cycles;\n/**\n* DATA\n*/\n// let V = [[0.5774, 1.0], [1.0, 1.0], [1.1547, 0.0], [1.0, 0.0], [0.0, 0.0], [0.0, 0.732], [1.0, 0.1547], [0.732, 0.0], [1.0491, 0.183], [-0.317, 0.549], [1.0, 0.268], [0.183, -0.3169], [0.5491, 1.049], [0.4642, 1.0], [0.0, -0.4226], [0.0, 1.0]]\n// let EV = [[0, 1], [2, 3], [5, 4], [7, 6], [2, 8], [3, 6], [4, 9], [0, 10], [9, 5], [8, 10], [7, 11], [12, 13], [6, 8], [6, 10], [4, 7], [4, 11], [4, 14], [5, 15], [11, 14], [0, 12], [13, 15], [0, 13], [1, 10], [3, 7], [5, 13]]\n// let V = [[0,0],[10,0],[10,10],[0,10], [100,100],[110,100],[110,110],[100,110], [5,0], [5,10]]\n// let V = [[0,0.5],[12,-0.7],[14,14],[-2,10], [103,106],[117,98],[96,112],[104,109], [5.5,0.8], [4.8,10.5]]\n// let EV = [[3,9],[9,2],[2,1],[1,8],[8,0],[0,3],[8,9]] // IT WORKS\n// let EV = [[3,9],[9,2],[2,1],[1,8],[8,0],[0,3],[8,9], [5,6], [6,7], [2,5]] // IT DOESN'T WORK\n// let EV = [[3,2],[2,1],[1,0],[0,3]] // IT WORKS\n// let EV = [[2,3],[1,2],[0,1],[3,0]] // IT WORKS\n// let EV = [[2,3],[1,2],[0,1],[3,0],[6,7],[5,6],[4,5],[7,4]] // IT WORKS\n// let EV = [[3,2],[2,1],[1,0],[0,3],[7,6],[6,5],[5,4],[4,7]] // IT WORKS\n// let V = [[2,5],[5,6],[10,6.8],[23,8],[9.6,11.3],[20,15],[25,16],[29,18],[30,22],[4,11],[6,10],[24,25],[18,20],[27,7]]\n// let EV = [[0,1],[10,0],[9,10],[9,1],[1,2],[4,2],[3,13],[2,3],[4,5],[5,6],[6,7],[12,5],[12,11],[11,6],[11,8],[7,8],[9,4]]\n\n/**\n* MAIN\n*/\n// let cycles_data = find_inner_cycles(V, EV)\n// console.log('############## OUTPUT')\n// console.log('EDGES:')\n// console.log(cycles_data.e_cycles)\n// console.log('\\n')\n// console.log('VERTICES:')\n// console.log(cycles_data.v_cycles)\n// console.log('\\n')\n// console.log(cycles_data.ev_mapping.every(m => m.color === 2))","map":{"version":3,"sources":["/home/srihari/Desktop/Sparkplug_PandemicSparks/grid/node_modules/react-planner/es/utils/graph-cycles.js"],"names":["sub","v1","v2","mod","n","m","compute_ev_mapping","EV","ev_mapping","map","ev","color","direction","compute_angle","P","V","point","angle","Math","atan2","compute_incidences","incidences","vertex","i","incidence","forEach","edge","j","endpoint","position","undefined","push","index","sort","i1","i2","get_starting_edge","e","length","get_next_edge","items","n_items","item","out","find_cycles","V_cycles","E_cycles","dir_E_cycles","V_cycle","E_cycle","dir_E_cycle","next","counter","start","v_cycles","e_cycles","dir_e_cycles","find_short_cycles_indexes","indexes","e_cycle","v_cycle","find_inner_cycles","cycles","short_cycles_indexes","indx","splice","rooms_values","cycle","dir","rooms_sums","room","reduce","a","b","positive_count","filter","sum","negative_count","rm_neg","v","module","exports"],"mappings":"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","sourcesContent":["/**\n * UTILS\n */\n\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\nfunction mod(n, m) {\n  return (n % m + m) % m;\n}\n\n/**\n * CYCLES\n */\n\nfunction compute_ev_mapping(EV) {\n  var ev_mapping = EV.map(function (ev) {\n    return {\n      ev: ev,\n      color: 0,\n      direction: -1\n    };\n  });\n\n  return ev_mapping;\n}\n\nfunction compute_angle(P, V) {\n  var point = sub(V, P);\n  var angle = Math.atan2(point[1], point[0]);\n  return angle;\n}\n\nfunction compute_incidences(V, EV) {\n  var incidences = V.map(function (vertex, i) {\n    var incidence = [];\n    EV.forEach(function (edge, j) {\n      var endpoint = void 0;\n      var position = void 0;\n\n      if (edge[0] === i) {\n        endpoint = edge[1];\n        position = 1;\n      }\n\n      if (edge[1] === i) {\n        endpoint = edge[0];\n        position = 0;\n      }\n\n      endpoint !== undefined && incidence.push({\n        index: j,\n        endpoint: endpoint,\n        angle: compute_angle(vertex, V[endpoint]),\n        edge: edge,\n        position: position\n      });\n    });\n\n    incidence.sort(function (i1, i2) {\n      return i2.angle - i1.angle;\n    });\n\n    return incidence;\n  });\n\n  return incidences;\n}\n\nfunction get_starting_edge(incidences, ev_mapping) {\n  var e = void 0;\n  var position = void 0;\n  var direction = void 0;\n  for (e = 0; e < ev_mapping.length; e += 1) {\n    if (ev_mapping[e].color < 2) {\n      direction = -1 * ev_mapping[e].direction;\n      color(ev_mapping, e, direction);\n      return {\n        edge: e,\n        direction: direction,\n        position: direction === -1 ? 0 : 1\n      };\n    }\n  }\n}\n\nfunction get_next_edge(incidences, edge, position, EV) {\n  var items = incidences[EV[edge][position]];\n  //console.log(items, incidences, EV, edge, position);\n  var n_items = items.length;\n  var item = void 0;\n  var out = void 0;\n  var j = void 0;\n  for (j = 0; j < n_items; j += 1) {\n    item = items[j];\n    if (item.index === edge) {\n      out = items[mod(j + 1, items.length)];\n      return {\n        edge: out.index,\n        vertex: out.endpoint,\n        position: out.position,\n        direction: out.position ? 1 : -1\n      };\n    }\n  }\n}\n\nfunction color(ev_mapping, index, direction) {\n  ev_mapping[index].color += 1;\n  ev_mapping[index].direction = direction;\n}\n\nfunction find_cycles(V, EV) {\n  var ev_mapping = compute_ev_mapping(EV);\n  var incidences = compute_incidences(V, EV);\n  var V_cycles = [];\n  var E_cycles = [];\n  var dir_E_cycles = [];\n  var V_cycle = void 0;\n  var E_cycle = void 0;\n  var dir_E_cycle = void 0;\n  var next = void 0;\n  var counter = 0;\n  var start = get_starting_edge(incidences, ev_mapping);\n\n  while (start !== undefined) {\n    V_cycle = [EV[start.edge][mod(start.position + 1, 2)], EV[start.edge][start.position]];\n    E_cycle = [start.edge];\n    dir_E_cycle = [start.direction];\n    next = get_next_edge(incidences, start.edge, start.position, EV);\n    while (next.edge !== start.edge) {\n      V_cycle.push(next.vertex);\n      E_cycle.push(next.edge);\n      dir_E_cycle.push(next.direction);\n      color(ev_mapping, next.edge, next.direction);\n      next = get_next_edge(incidences, next.edge, next.position, EV);\n    }\n    E_cycles.push(E_cycle);\n    V_cycles.push(V_cycle);\n    dir_E_cycles.push(dir_E_cycle);\n\n    //console.log('############## CYCLE ', ++counter)\n    //console.log('EDGES:', E_cycle)\n    //console.log('VERTICES:', V_cycle)\n    //console.log('START', 'edge:', start.edge, 'position:', start.position)\n    //console.log('COUNTER:', ev_mapping.map(e => e.color), ev_mapping.map(e => e.color).reduce((a, b) => a + b));\n    //console.log('\\n')\n\n    start = get_starting_edge(incidences, ev_mapping);\n  }\n\n  return {\n    v_cycles: V_cycles,\n    e_cycles: E_cycles,\n    dir_e_cycles: dir_E_cycles,\n    ev_mapping: ev_mapping\n  };\n}\n\nfunction find_short_cycles_indexes(v_cycles, e_cycles) {\n  var indexes = [];\n  var e_cycle = void 0;\n  var v_cycle = void 0;\n  var i = void 0;\n\n  for (i = 0; i < e_cycles.length; i += 1) {\n    e_cycle = e_cycles[i];\n    v_cycle = v_cycles[i];\n    if (e_cycle.length < 3 || v_cycle[0] !== v_cycle[v_cycle.length - 1]) {\n      indexes.push(i);\n    }\n  }\n\n  return indexes;\n}\n\nfunction find_inner_cycles(V, EV) {\n  var cycles = find_cycles(V, EV);\n  var v_cycles = cycles.v_cycles;\n  var e_cycles = cycles.e_cycles;\n  var short_cycles_indexes = find_short_cycles_indexes(v_cycles, e_cycles);\n  short_cycles_indexes.forEach(function (indx) {\n    v_cycles.splice(indx, 1);\n    e_cycles.splice(indx, 1);\n  });\n  var dir_e_cycles = cycles.dir_e_cycles;\n  var rooms_values = cycles.e_cycles.map(function (cycle, i) {\n    return cycle.map(function (edge, j) {\n      var v1 = void 0;\n      var v2 = void 0;\n\n      var dir = dir_e_cycles[i][j] > 0;\n\n      if (dir > 0) {\n        v1 = EV[edge][0];\n        v2 = EV[edge][1];\n      } else {\n        v1 = EV[edge][1];\n        v2 = EV[edge][0];\n      }\n\n      return (V[v2][0] - V[v1][0]) * (V[v2][1] + V[v1][1]);\n    });\n  });\n\n  var rooms_sums = rooms_values.map(function (room) {\n    return room.reduce(function (a, b) {\n      return a + b;\n    });\n  });\n\n  var positive_count = rooms_sums.filter(function (sum) {\n    return sum > 0;\n  }).length;\n  var negative_count = rooms_sums.length - positive_count;\n\n  var rm_neg = positive_count >= negative_count ? 1 : -1;\n\n  return {\n    v_cycles: cycles.v_cycles.filter(function (v, i) {\n      return rm_neg * rooms_sums[i] > 0;\n    }),\n    e_cycles: cycles.e_cycles.filter(function (v, i) {\n      return rm_neg * rooms_sums[i] > 0;\n    }),\n    ev_mapping: cycles.ev_mapping\n  };\n}\n\n// export default find_inner_cycles;\nmodule.exports = find_inner_cycles;\n\n/**\n* DATA\n*/\n\n// let V = [[0.5774, 1.0], [1.0, 1.0], [1.1547, 0.0], [1.0, 0.0], [0.0, 0.0], [0.0, 0.732], [1.0, 0.1547], [0.732, 0.0], [1.0491, 0.183], [-0.317, 0.549], [1.0, 0.268], [0.183, -0.3169], [0.5491, 1.049], [0.4642, 1.0], [0.0, -0.4226], [0.0, 1.0]]\n// let EV = [[0, 1], [2, 3], [5, 4], [7, 6], [2, 8], [3, 6], [4, 9], [0, 10], [9, 5], [8, 10], [7, 11], [12, 13], [6, 8], [6, 10], [4, 7], [4, 11], [4, 14], [5, 15], [11, 14], [0, 12], [13, 15], [0, 13], [1, 10], [3, 7], [5, 13]]\n\n// let V = [[0,0],[10,0],[10,10],[0,10], [100,100],[110,100],[110,110],[100,110], [5,0], [5,10]]\n// let V = [[0,0.5],[12,-0.7],[14,14],[-2,10], [103,106],[117,98],[96,112],[104,109], [5.5,0.8], [4.8,10.5]]\n// let EV = [[3,9],[9,2],[2,1],[1,8],[8,0],[0,3],[8,9]] // IT WORKS\n// let EV = [[3,9],[9,2],[2,1],[1,8],[8,0],[0,3],[8,9], [5,6], [6,7], [2,5]] // IT DOESN'T WORK\n// let EV = [[3,2],[2,1],[1,0],[0,3]] // IT WORKS\n// let EV = [[2,3],[1,2],[0,1],[3,0]] // IT WORKS\n// let EV = [[2,3],[1,2],[0,1],[3,0],[6,7],[5,6],[4,5],[7,4]] // IT WORKS\n// let EV = [[3,2],[2,1],[1,0],[0,3],[7,6],[6,5],[5,4],[4,7]] // IT WORKS\n\n// let V = [[2,5],[5,6],[10,6.8],[23,8],[9.6,11.3],[20,15],[25,16],[29,18],[30,22],[4,11],[6,10],[24,25],[18,20],[27,7]]\n// let EV = [[0,1],[10,0],[9,10],[9,1],[1,2],[4,2],[3,13],[2,3],[4,5],[5,6],[6,7],[12,5],[12,11],[11,6],[11,8],[7,8],[9,4]]\n\n/**\n* MAIN\n*/\n\n// let cycles_data = find_inner_cycles(V, EV)\n// console.log('############## OUTPUT')\n// console.log('EDGES:')\n// console.log(cycles_data.e_cycles)\n// console.log('\\n')\n// console.log('VERTICES:')\n// console.log(cycles_data.v_cycles)\n// console.log('\\n')\n// console.log(cycles_data.ev_mapping.every(m => m.color === 2))"]},"metadata":{},"sourceType":"script"}