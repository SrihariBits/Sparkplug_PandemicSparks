{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nimport { Map, List, fromJS } from 'immutable';\nimport { Layer, Group } from './export';\nimport { IDBroker, NameGenerator } from '../utils/export';\nimport { nearestSnap, addLineSegmentSnap } from '../utils/snap';\nimport { MODE_IDLE, MODE_DRAWING_HOLE, MODE_DRAGGING_HOLE } from '../constants';\nimport { GeometryUtils } from '../utils/export';\n\nvar Hole = function () {\n  function Hole() {\n    _classCallCheck(this, Hole);\n  }\n\n  _createClass(Hole, null, [{\n    key: 'create',\n    value: function create(state, layerID, type, lineID, offset, properties) {\n      var holeID = IDBroker.acquireID();\n      var hole = state.catalog.factoryElement(type, {\n        id: holeID,\n        name: NameGenerator.generateName('holes', state.catalog.getIn(['elements', type, 'info', 'title'])),\n        type: type,\n        offset: offset,\n        line: lineID\n      }, properties);\n      state = state.setIn(['scene', 'layers', layerID, 'holes', holeID], hole);\n      state = state.updateIn(['scene', 'layers', layerID, 'lines', lineID, 'holes'], function (holes) {\n        return holes.push(holeID);\n      });\n      return {\n        updatedState: state,\n        hole: hole\n      };\n    }\n  }, {\n    key: 'select',\n    value: function select(state, layerID, holeID) {\n      state = Layer.select(state, layerID).updatedState;\n      state = Layer.selectElement(state, layerID, 'holes', holeID).updatedState;\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'remove',\n    value: function remove(state, layerID, holeID) {\n      var hole = state.getIn(['scene', 'layers', layerID, 'holes', holeID]);\n      state = this.unselect(state, layerID, holeID).updatedState;\n      state = Layer.removeElement(state, layerID, 'holes', holeID).updatedState;\n      state = state.updateIn(['scene', 'layers', layerID, 'lines', hole.line, 'holes'], function (holes) {\n        var index = holes.findIndex(function (ID) {\n          return holeID === ID;\n        });\n        return index !== -1 ? holes.remove(index) : holes;\n      });\n      state.getIn(['scene', 'groups']).forEach(function (group) {\n        return state = Group.removeElement(state, group.id, layerID, 'holes', holeID).updatedState;\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'unselect',\n    value: function unselect(state, layerID, holeID) {\n      state = Layer.unselect(state, layerID, 'holes', holeID).updatedState;\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'selectToolDrawingHole',\n    value: function selectToolDrawingHole(state, sceneComponentType) {\n      var snapElements = new List().withMutations(function (snapElements) {\n        var _state$getIn = state.getIn(['scene', 'layers', state.scene.selectedLayer]),\n            lines = _state$getIn.lines,\n            vertices = _state$getIn.vertices;\n\n        lines.forEach(function (line) {\n          var _vertices$get = vertices.get(line.vertices.get(0)),\n              x1 = _vertices$get.x,\n              y1 = _vertices$get.y;\n\n          var _vertices$get2 = vertices.get(line.vertices.get(1)),\n              x2 = _vertices$get2.x,\n              y2 = _vertices$get2.y;\n\n          addLineSegmentSnap(snapElements, x1, y1, x2, y2, 20, 1, line.id);\n        });\n      });\n      state = state.merge({\n        mode: MODE_DRAWING_HOLE,\n        snapElements: snapElements,\n        drawingSupport: Map({\n          type: sceneComponentType\n        })\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'updateDrawingHole',\n    value: function updateDrawingHole(state, layerID, x, y) {\n      var catalog = state.catalog; //calculate snap and overwrite coords if needed\n      //force snap to segment\n\n      var snap = nearestSnap(state.snapElements, x, y, state.snapMask.merge({\n        SNAP_SEGMENT: true\n      }));\n\n      if (snap) {\n        ;\n        var _snap$point = snap.point;\n        x = _snap$point.x;\n        y = _snap$point.y;\n      }\n\n      var selectedHole = state.getIn(['scene', 'layers', layerID, 'selected', 'holes']).first();\n\n      if (snap) {\n        var lineID = snap.snap.related.get(0);\n        var vertices = state.getIn(['scene', 'layers', layerID, 'lines', lineID, 'vertices']);\n\n        var _state$getIn2 = state.getIn(['scene', 'layers', layerID, 'vertices', vertices.get(0)]),\n            x1 = _state$getIn2.x,\n            y1 = _state$getIn2.y;\n\n        var _state$getIn3 = state.getIn(['scene', 'layers', layerID, 'vertices', vertices.get(1)]),\n            x2 = _state$getIn3.x,\n            y2 = _state$getIn3.y; // I need min and max vertices on this line segment\n\n\n        var minVertex = GeometryUtils.minVertex({\n          x: x1,\n          y: y1\n        }, {\n          x: x2,\n          y: y2\n        });\n        var maxVertex = GeometryUtils.maxVertex({\n          x: x1,\n          y: y1\n        }, {\n          x: x2,\n          y: y2\n        });\n        var width = catalog.factoryElement(state.drawingSupport.get('type')).properties.getIn(['width', 'length']); // Now I need min and max possible coordinates for the hole on the line. They depend on the width of the hole\n\n        var lineLength = GeometryUtils.pointsDistance(x1, y1, x2, y2);\n        var alpha = GeometryUtils.absAngleBetweenTwoPoints(x1, y1, x2, y2);\n        var cosAlpha = GeometryUtils.cosWithThreshold(alpha, 0.0000001);\n        var sinAlpha = GeometryUtils.sinWithThreshold(alpha, 0.0000001);\n        var minLeftVertexHole = {\n          x: minVertex.x + width / 2 * cosAlpha,\n          y: minVertex.y + width / 2 * sinAlpha\n        };\n        var maxRightVertexHole = {\n          x: minVertex.x + lineLength * cosAlpha - width / 2 * cosAlpha,\n          y: minVertex.y + lineLength * sinAlpha - width / 2 * sinAlpha\n        };\n        var offset = void 0;\n\n        if (x < minLeftVertexHole.x) {\n          offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, minLeftVertexHole.x, minLeftVertexHole.y);\n        } else if (x > maxRightVertexHole.x) {\n          offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, maxRightVertexHole.x, maxRightVertexHole.y);\n        } else {\n          if (x === minLeftVertexHole.x && x === maxRightVertexHole.x) {\n            if (y < minLeftVertexHole.y) {\n              offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, minLeftVertexHole.x, minLeftVertexHole.y);\n              offset = minVertex.x === x1 && minVertex.y === y1 ? offset : 1 - offset;\n            } else if (y > maxRightVertexHole.y) {\n              offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, maxRightVertexHole.x, maxRightVertexHole.y);\n              offset = minVertex.x === x1 && minVertex.y === y1 ? offset : 1 - offset;\n            } else {\n              offset = GeometryUtils.pointPositionOnLineSegment(x1, y1, x2, y2, x, y);\n            }\n          } else {\n            offset = GeometryUtils.pointPositionOnLineSegment(x1, y1, x2, y2, x, y);\n          }\n        } //if hole does exist, update\n\n\n        if (selectedHole && snap) {\n          state = state.mergeIn(['scene', 'layers', layerID, 'holes', selectedHole], {\n            offset: offset,\n            line: lineID\n          }); //remove from old line ( if present )\n\n          var index = state.getIn(['scene', 'layers', layerID, 'lines']).findEntry(function (line) {\n            return line.id !== lineID && line.get('holes').contains(selectedHole);\n          });\n\n          if (index) {\n            var removed = index[1].get('holes').filter(function (hl) {\n              return hl !== selectedHole;\n            });\n            state = state.setIn(['scene', 'layers', layerID, 'lines', index[0], 'holes'], removed);\n          } //add to line\n\n\n          var line_holes = state.getIn(['scene', 'layers', layerID, 'lines', lineID, 'holes']);\n\n          if (!line_holes.contains(selectedHole)) {\n            state = state.setIn(['scene', 'layers', layerID, 'lines', lineID, 'holes'], line_holes.push(selectedHole));\n          }\n        } else if (!selectedHole && snap) {\n          //if hole does not exist, create\n          var _create = this.create(state, layerID, state.drawingSupport.get('type'), lineID, offset),\n              stateH = _create.updatedState,\n              hole = _create.hole;\n\n          state = Hole.select(stateH, layerID, hole.id).updatedState;\n        }\n      } //i've lost the snap while trying to drop the hole\n      else if (false && selectedHole) //think if enable\n          {\n            state = Hole.remove(state, layerID, selectedHole).updatedState;\n          }\n\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'endDrawingHole',\n    value: function endDrawingHole(state, layerID, x, y) {\n      state = this.updateDrawingHole(state, layerID, x, y).updatedState;\n      state = Layer.unselectAll(state, layerID).updatedState;\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'beginDraggingHole',\n    value: function beginDraggingHole(state, layerID, holeID, x, y) {\n      var layer = state.getIn(['scene', 'layers', layerID]);\n      var hole = layer.getIn(['holes', holeID]);\n      var line = layer.getIn(['lines', hole.line]);\n      var v0 = layer.getIn(['vertices', line.vertices.get(0)]);\n      var v1 = layer.getIn(['vertices', line.vertices.get(1)]);\n      var snapElements = addLineSegmentSnap(List(), v0.x, v0.y, v1.x, v1.y, 9999999, 1, null);\n      state = state.merge({\n        mode: MODE_DRAGGING_HOLE,\n        snapElements: snapElements,\n        draggingSupport: Map({\n          layerID: layerID,\n          holeID: holeID,\n          startPointX: x,\n          startPointY: y\n        })\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'updateDraggingHole',\n    value: function updateDraggingHole(state, x, y) {\n      //calculate snap and overwrite coords if needed\n      //force snap to segment\n      var snap = nearestSnap(state.snapElements, x, y, state.snapMask.merge({\n        SNAP_SEGMENT: true\n      }));\n      if (!snap) return state;\n      var _state = state,\n          draggingSupport = _state.draggingSupport,\n          scene = _state.scene;\n      var layerID = draggingSupport.get('layerID');\n      var holeID = draggingSupport.get('holeID');\n      var startPointX = draggingSupport.get('startPointX');\n      var startPointY = draggingSupport.get('startPointY');\n      var layer = state.getIn(['scene', 'layers', layerID]);\n      var hole = layer.getIn(['holes', holeID]);\n      var line = layer.getIn(['lines', hole.line]);\n      var v0 = layer.getIn(['vertices', line.vertices.get(0)]);\n      var v1 = layer.getIn(['vertices', line.vertices.get(1)]); // I need min and max vertices on this line segment\n\n      var _snap$point2 = snap.point;\n      x = _snap$point2.x;\n      y = _snap$point2.y;\n      var minVertex = GeometryUtils.minVertex(v0, v1);\n      var maxVertex = GeometryUtils.maxVertex(v0, v1); // Now I need min and max possible coordinates for the hole on the line. They depend on the width of the hole\n\n      var width = hole.properties.get('width').get('length');\n      var lineLength = GeometryUtils.pointsDistance(v0.x, v0.y, v1.x, v1.y);\n      var alpha = Math.atan2(Math.abs(v1.y - v0.y), Math.abs(v1.x - v0.x));\n\n      var cosWithThreshold = function cosWithThreshold(alpha) {\n        var cos = Math.cos(alpha);\n        return cos < 0.0000001 ? 0 : cos;\n      };\n\n      var sinWithThreshold = function sinWithThreshold(alpha) {\n        var sin = Math.sin(alpha);\n        return sin < 0.0000001 ? 0 : sin;\n      };\n\n      var cosAlpha = cosWithThreshold(alpha);\n      var sinAlpha = sinWithThreshold(alpha);\n      var minLeftVertexHole = {\n        x: minVertex.x + width / 2 * cosAlpha,\n        y: minVertex.y + width / 2 * sinAlpha\n      };\n      var maxRightVertexHole = {\n        x: minVertex.x + lineLength * cosAlpha - width / 2 * cosAlpha,\n        y: minVertex.y + lineLength * sinAlpha - width / 2 * sinAlpha\n      }; // Now I need to verify if the snap vertex (with coordinates x and y) is on the line segment\n\n      var offset = void 0;\n\n      if (x < minLeftVertexHole.x) {\n        // Snap point is previous the the line\n        offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, minLeftVertexHole.x, minLeftVertexHole.y);\n      } else {\n        // Snap point is after the line or on the line\n        if (x > maxRightVertexHole.x) {\n          offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, maxRightVertexHole.x, maxRightVertexHole.y);\n        } else if (x === minLeftVertexHole.x && x === maxRightVertexHole.x) {\n          // I am on a vertical line, I need to check y coordinates\n          if (y < minLeftVertexHole.y) {\n            offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, minLeftVertexHole.x, minLeftVertexHole.y);\n            offset = minVertex === v0 ? offset : 1 - offset;\n          } else if (y > maxRightVertexHole.y) {\n            offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, maxRightVertexHole.x, maxRightVertexHole.y);\n            offset = minVertex === v0 ? offset : 1 - offset;\n          } else {\n            offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, x, y);\n            offset = minVertex === v0 ? offset : 1 - offset;\n          }\n        } else {\n          offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, x, y);\n        }\n      }\n\n      hole = hole.set('offset', offset);\n      state = state.merge({\n        scene: scene.mergeIn(['layers', layerID, 'holes', holeID], hole)\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'endDraggingHole',\n    value: function endDraggingHole(state, x, y) {\n      state = this.updateDraggingHole(state, x, y).updatedState;\n      state = state.merge({\n        mode: MODE_IDLE\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'setProperties',\n    value: function setProperties(state, layerID, holeID, properties) {\n      state = state.setIn(['scene', 'layers', layerID, 'holes', holeID, 'properties'], properties);\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'setJsProperties',\n    value: function setJsProperties(state, layerID, holeID, properties) {\n      return this.setProperties(state, layerID, holeID, fromJS(properties));\n    }\n  }, {\n    key: 'updateProperties',\n    value: function updateProperties(state, layerID, holeID, properties) {\n      properties.forEach(function (v, k) {\n        if (state.hasIn(['scene', 'layers', layerID, 'holes', holeID, 'properties', k])) state = state.mergeIn(['scene', 'layers', layerID, 'holes', holeID, 'properties', k], v);\n      });\n      return {\n        updatedState: state\n      };\n    }\n  }, {\n    key: 'updateJsProperties',\n    value: function updateJsProperties(state, layerID, holeID, properties) {\n      return this.updateProperties(state, layerID, holeID, fromJS(properties));\n    }\n  }, {\n    key: 'setAttributes',\n    value: function setAttributes(state, layerID, holeID, holesAttributes) {\n      var hAttr = holesAttributes.toJS();\n      var offsetA = hAttr.offsetA,\n          offsetB = hAttr.offsetB,\n          offset = hAttr.offset;\n      delete hAttr['offsetA'];\n      delete hAttr['offsetB'];\n      delete hAttr['offset'];\n      var misc = new Map({\n        _unitA: offsetA._unit,\n        _unitB: offsetB._unit\n      });\n      state = state.mergeIn(['scene', 'layers', layerID, 'holes', holeID], fromJS(hAttr)).mergeDeepIn(['scene', 'layers', layerID, 'holes', holeID], new Map({\n        offset: offset,\n        misc: misc\n      }));\n      return {\n        updatedState: state\n      };\n    }\n  }]);\n\n  return Hole;\n}();\n\nexport { Hole as default };","map":{"version":3,"sources":["/home/srihari/Desktop/Sparkplug_PandemicSparks/grid/node_modules/react-planner/es/class/hole.js"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","Map","List","fromJS","Layer","Group","IDBroker","NameGenerator","nearestSnap","addLineSegmentSnap","MODE_IDLE","MODE_DRAWING_HOLE","MODE_DRAGGING_HOLE","GeometryUtils","Hole","value","create","state","layerID","type","lineID","offset","properties","holeID","acquireID","hole","catalog","factoryElement","id","name","generateName","getIn","line","setIn","updateIn","holes","push","updatedState","select","selectElement","remove","unselect","removeElement","index","findIndex","ID","forEach","group","selectToolDrawingHole","sceneComponentType","snapElements","withMutations","_state$getIn","scene","selectedLayer","lines","vertices","_vertices$get","get","x1","x","y1","y","_vertices$get2","x2","y2","merge","mode","drawingSupport","updateDrawingHole","snap","snapMask","SNAP_SEGMENT","_snap$point","point","selectedHole","first","related","_state$getIn2","_state$getIn3","minVertex","maxVertex","width","lineLength","pointsDistance","alpha","absAngleBetweenTwoPoints","cosAlpha","cosWithThreshold","sinAlpha","sinWithThreshold","minLeftVertexHole","maxRightVertexHole","pointPositionOnLineSegment","mergeIn","findEntry","contains","removed","filter","hl","line_holes","_create","stateH","endDrawingHole","unselectAll","beginDraggingHole","layer","v0","v1","draggingSupport","startPointX","startPointY","updateDraggingHole","_state","_snap$point2","Math","atan2","abs","cos","sin","set","endDraggingHole","setProperties","setJsProperties","updateProperties","v","k","hasIn","updateJsProperties","setAttributes","holesAttributes","hAttr","toJS","offsetA","offsetB","misc","_unitA","_unit","_unitB","mergeDeepIn","default"],"mappings":"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","sourcesContent":["var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nimport { Map, List, fromJS } from 'immutable';\nimport { Layer, Group } from './export';\n\nimport { IDBroker, NameGenerator } from '../utils/export';\n\nimport { nearestSnap, addLineSegmentSnap } from '../utils/snap';\n\nimport { MODE_IDLE, MODE_DRAWING_HOLE, MODE_DRAGGING_HOLE } from '../constants';\n\nimport { GeometryUtils } from '../utils/export';\n\nvar Hole = function () {\n  function Hole() {\n    _classCallCheck(this, Hole);\n  }\n\n  _createClass(Hole, null, [{\n    key: 'create',\n    value: function create(state, layerID, type, lineID, offset, properties) {\n\n      var holeID = IDBroker.acquireID();\n\n      var hole = state.catalog.factoryElement(type, {\n        id: holeID,\n        name: NameGenerator.generateName('holes', state.catalog.getIn(['elements', type, 'info', 'title'])),\n        type: type,\n        offset: offset,\n        line: lineID\n      }, properties);\n\n      state = state.setIn(['scene', 'layers', layerID, 'holes', holeID], hole);\n      state = state.updateIn(['scene', 'layers', layerID, 'lines', lineID, 'holes'], function (holes) {\n        return holes.push(holeID);\n      });\n\n      return { updatedState: state, hole: hole };\n    }\n  }, {\n    key: 'select',\n    value: function select(state, layerID, holeID) {\n      state = Layer.select(state, layerID).updatedState;\n      state = Layer.selectElement(state, layerID, 'holes', holeID).updatedState;\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'remove',\n    value: function remove(state, layerID, holeID) {\n      var hole = state.getIn(['scene', 'layers', layerID, 'holes', holeID]);\n      state = this.unselect(state, layerID, holeID).updatedState;\n      state = Layer.removeElement(state, layerID, 'holes', holeID).updatedState;\n\n      state = state.updateIn(['scene', 'layers', layerID, 'lines', hole.line, 'holes'], function (holes) {\n        var index = holes.findIndex(function (ID) {\n          return holeID === ID;\n        });\n        return index !== -1 ? holes.remove(index) : holes;\n      });\n\n      state.getIn(['scene', 'groups']).forEach(function (group) {\n        return state = Group.removeElement(state, group.id, layerID, 'holes', holeID).updatedState;\n      });\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'unselect',\n    value: function unselect(state, layerID, holeID) {\n      state = Layer.unselect(state, layerID, 'holes', holeID).updatedState;\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'selectToolDrawingHole',\n    value: function selectToolDrawingHole(state, sceneComponentType) {\n\n      var snapElements = new List().withMutations(function (snapElements) {\n        var _state$getIn = state.getIn(['scene', 'layers', state.scene.selectedLayer]),\n            lines = _state$getIn.lines,\n            vertices = _state$getIn.vertices;\n\n        lines.forEach(function (line) {\n          var _vertices$get = vertices.get(line.vertices.get(0)),\n              x1 = _vertices$get.x,\n              y1 = _vertices$get.y;\n\n          var _vertices$get2 = vertices.get(line.vertices.get(1)),\n              x2 = _vertices$get2.x,\n              y2 = _vertices$get2.y;\n\n          addLineSegmentSnap(snapElements, x1, y1, x2, y2, 20, 1, line.id);\n        });\n      });\n\n      state = state.merge({\n        mode: MODE_DRAWING_HOLE,\n        snapElements: snapElements,\n        drawingSupport: Map({\n          type: sceneComponentType\n        })\n      });\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'updateDrawingHole',\n    value: function updateDrawingHole(state, layerID, x, y) {\n      var catalog = state.catalog;\n\n      //calculate snap and overwrite coords if needed\n      //force snap to segment\n      var snap = nearestSnap(state.snapElements, x, y, state.snapMask.merge({ SNAP_SEGMENT: true }));\n      if (snap) {\n        ;\n\n        var _snap$point = snap.point;\n        x = _snap$point.x;\n        y = _snap$point.y;\n      }var selectedHole = state.getIn(['scene', 'layers', layerID, 'selected', 'holes']).first();\n\n      if (snap) {\n        var lineID = snap.snap.related.get(0);\n\n        var vertices = state.getIn(['scene', 'layers', layerID, 'lines', lineID, 'vertices']);\n\n        var _state$getIn2 = state.getIn(['scene', 'layers', layerID, 'vertices', vertices.get(0)]),\n            x1 = _state$getIn2.x,\n            y1 = _state$getIn2.y;\n\n        var _state$getIn3 = state.getIn(['scene', 'layers', layerID, 'vertices', vertices.get(1)]),\n            x2 = _state$getIn3.x,\n            y2 = _state$getIn3.y;\n\n        // I need min and max vertices on this line segment\n\n\n        var minVertex = GeometryUtils.minVertex({ x: x1, y: y1 }, { x: x2, y: y2 });\n        var maxVertex = GeometryUtils.maxVertex({ x: x1, y: y1 }, { x: x2, y: y2 });\n        var width = catalog.factoryElement(state.drawingSupport.get('type')).properties.getIn(['width', 'length']);\n\n        // Now I need min and max possible coordinates for the hole on the line. They depend on the width of the hole\n        var lineLength = GeometryUtils.pointsDistance(x1, y1, x2, y2);\n        var alpha = GeometryUtils.absAngleBetweenTwoPoints(x1, y1, x2, y2);\n\n        var cosAlpha = GeometryUtils.cosWithThreshold(alpha, 0.0000001);\n        var sinAlpha = GeometryUtils.sinWithThreshold(alpha, 0.0000001);\n\n        var minLeftVertexHole = {\n          x: minVertex.x + width / 2 * cosAlpha,\n          y: minVertex.y + width / 2 * sinAlpha\n        };\n\n        var maxRightVertexHole = {\n          x: minVertex.x + lineLength * cosAlpha - width / 2 * cosAlpha,\n          y: minVertex.y + lineLength * sinAlpha - width / 2 * sinAlpha\n        };\n\n        var offset = void 0;\n        if (x < minLeftVertexHole.x) {\n          offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, minLeftVertexHole.x, minLeftVertexHole.y);\n        } else if (x > maxRightVertexHole.x) {\n          offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, maxRightVertexHole.x, maxRightVertexHole.y);\n        } else {\n\n          if (x === minLeftVertexHole.x && x === maxRightVertexHole.x) {\n            if (y < minLeftVertexHole.y) {\n              offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, minLeftVertexHole.x, minLeftVertexHole.y);\n              offset = minVertex.x === x1 && minVertex.y === y1 ? offset : 1 - offset;\n            } else if (y > maxRightVertexHole.y) {\n              offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, maxRightVertexHole.x, maxRightVertexHole.y);\n              offset = minVertex.x === x1 && minVertex.y === y1 ? offset : 1 - offset;\n            } else {\n              offset = GeometryUtils.pointPositionOnLineSegment(x1, y1, x2, y2, x, y);\n            }\n          } else {\n            offset = GeometryUtils.pointPositionOnLineSegment(x1, y1, x2, y2, x, y);\n          }\n        }\n\n        //if hole does exist, update\n        if (selectedHole && snap) {\n          state = state.mergeIn(['scene', 'layers', layerID, 'holes', selectedHole], { offset: offset, line: lineID });\n\n          //remove from old line ( if present )\n          var index = state.getIn(['scene', 'layers', layerID, 'lines']).findEntry(function (line) {\n            return line.id !== lineID && line.get('holes').contains(selectedHole);\n          });\n\n          if (index) {\n            var removed = index[1].get('holes').filter(function (hl) {\n              return hl !== selectedHole;\n            });\n            state = state.setIn(['scene', 'layers', layerID, 'lines', index[0], 'holes'], removed);\n          }\n\n          //add to line\n          var line_holes = state.getIn(['scene', 'layers', layerID, 'lines', lineID, 'holes']);\n          if (!line_holes.contains(selectedHole)) {\n            state = state.setIn(['scene', 'layers', layerID, 'lines', lineID, 'holes'], line_holes.push(selectedHole));\n          }\n        } else if (!selectedHole && snap) {\n          //if hole does not exist, create\n          var _create = this.create(state, layerID, state.drawingSupport.get('type'), lineID, offset),\n              stateH = _create.updatedState,\n              hole = _create.hole;\n\n          state = Hole.select(stateH, layerID, hole.id).updatedState;\n        }\n      }\n      //i've lost the snap while trying to drop the hole\n      else if (false && selectedHole) //think if enable\n          {\n            state = Hole.remove(state, layerID, selectedHole).updatedState;\n          }\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'endDrawingHole',\n    value: function endDrawingHole(state, layerID, x, y) {\n      state = this.updateDrawingHole(state, layerID, x, y).updatedState;\n      state = Layer.unselectAll(state, layerID).updatedState;\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'beginDraggingHole',\n    value: function beginDraggingHole(state, layerID, holeID, x, y) {\n      var layer = state.getIn(['scene', 'layers', layerID]);\n      var hole = layer.getIn(['holes', holeID]);\n      var line = layer.getIn(['lines', hole.line]);\n      var v0 = layer.getIn(['vertices', line.vertices.get(0)]);\n      var v1 = layer.getIn(['vertices', line.vertices.get(1)]);\n\n      var snapElements = addLineSegmentSnap(List(), v0.x, v0.y, v1.x, v1.y, 9999999, 1, null);\n\n      state = state.merge({\n        mode: MODE_DRAGGING_HOLE,\n        snapElements: snapElements,\n        draggingSupport: Map({\n          layerID: layerID,\n          holeID: holeID,\n          startPointX: x,\n          startPointY: y\n        })\n      });\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'updateDraggingHole',\n    value: function updateDraggingHole(state, x, y) {\n\n      //calculate snap and overwrite coords if needed\n      //force snap to segment\n      var snap = nearestSnap(state.snapElements, x, y, state.snapMask.merge({ SNAP_SEGMENT: true }));\n      if (!snap) return state;\n\n      var _state = state,\n          draggingSupport = _state.draggingSupport,\n          scene = _state.scene;\n\n\n      var layerID = draggingSupport.get('layerID');\n      var holeID = draggingSupport.get('holeID');\n      var startPointX = draggingSupport.get('startPointX');\n      var startPointY = draggingSupport.get('startPointY');\n\n      var layer = state.getIn(['scene', 'layers', layerID]);\n      var hole = layer.getIn(['holes', holeID]);\n      var line = layer.getIn(['lines', hole.line]);\n      var v0 = layer.getIn(['vertices', line.vertices.get(0)]);\n      var v1 = layer.getIn(['vertices', line.vertices.get(1)]);\n\n      // I need min and max vertices on this line segment\n      var _snap$point2 = snap.point;\n      x = _snap$point2.x;\n      y = _snap$point2.y;\n      var minVertex = GeometryUtils.minVertex(v0, v1);\n      var maxVertex = GeometryUtils.maxVertex(v0, v1);\n\n      // Now I need min and max possible coordinates for the hole on the line. They depend on the width of the hole\n\n      var width = hole.properties.get('width').get('length');\n      var lineLength = GeometryUtils.pointsDistance(v0.x, v0.y, v1.x, v1.y);\n      var alpha = Math.atan2(Math.abs(v1.y - v0.y), Math.abs(v1.x - v0.x));\n\n      var cosWithThreshold = function cosWithThreshold(alpha) {\n        var cos = Math.cos(alpha);\n        return cos < 0.0000001 ? 0 : cos;\n      };\n\n      var sinWithThreshold = function sinWithThreshold(alpha) {\n        var sin = Math.sin(alpha);\n        return sin < 0.0000001 ? 0 : sin;\n      };\n\n      var cosAlpha = cosWithThreshold(alpha);\n      var sinAlpha = sinWithThreshold(alpha);\n\n      var minLeftVertexHole = {\n        x: minVertex.x + width / 2 * cosAlpha,\n        y: minVertex.y + width / 2 * sinAlpha\n      };\n\n      var maxRightVertexHole = {\n        x: minVertex.x + lineLength * cosAlpha - width / 2 * cosAlpha,\n        y: minVertex.y + lineLength * sinAlpha - width / 2 * sinAlpha\n      };\n\n      // Now I need to verify if the snap vertex (with coordinates x and y) is on the line segment\n\n      var offset = void 0;\n\n      if (x < minLeftVertexHole.x) {\n        // Snap point is previous the the line\n        offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, minLeftVertexHole.x, minLeftVertexHole.y);\n      } else {\n        // Snap point is after the line or on the line\n        if (x > maxRightVertexHole.x) {\n          offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, maxRightVertexHole.x, maxRightVertexHole.y);\n        } else if (x === minLeftVertexHole.x && x === maxRightVertexHole.x) {\n          // I am on a vertical line, I need to check y coordinates\n          if (y < minLeftVertexHole.y) {\n            offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, minLeftVertexHole.x, minLeftVertexHole.y);\n\n            offset = minVertex === v0 ? offset : 1 - offset;\n          } else if (y > maxRightVertexHole.y) {\n            offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, maxRightVertexHole.x, maxRightVertexHole.y);\n\n            offset = minVertex === v0 ? offset : 1 - offset;\n          } else {\n            offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, x, y);\n\n            offset = minVertex === v0 ? offset : 1 - offset;\n          }\n        } else {\n          offset = GeometryUtils.pointPositionOnLineSegment(minVertex.x, minVertex.y, maxVertex.x, maxVertex.y, x, y);\n        }\n      }\n\n      hole = hole.set('offset', offset);\n\n      state = state.merge({\n        scene: scene.mergeIn(['layers', layerID, 'holes', holeID], hole)\n      });\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'endDraggingHole',\n    value: function endDraggingHole(state, x, y) {\n      state = this.updateDraggingHole(state, x, y).updatedState;\n      state = state.merge({ mode: MODE_IDLE });\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'setProperties',\n    value: function setProperties(state, layerID, holeID, properties) {\n      state = state.setIn(['scene', 'layers', layerID, 'holes', holeID, 'properties'], properties);\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'setJsProperties',\n    value: function setJsProperties(state, layerID, holeID, properties) {\n      return this.setProperties(state, layerID, holeID, fromJS(properties));\n    }\n  }, {\n    key: 'updateProperties',\n    value: function updateProperties(state, layerID, holeID, properties) {\n      properties.forEach(function (v, k) {\n        if (state.hasIn(['scene', 'layers', layerID, 'holes', holeID, 'properties', k])) state = state.mergeIn(['scene', 'layers', layerID, 'holes', holeID, 'properties', k], v);\n      });\n\n      return { updatedState: state };\n    }\n  }, {\n    key: 'updateJsProperties',\n    value: function updateJsProperties(state, layerID, holeID, properties) {\n      return this.updateProperties(state, layerID, holeID, fromJS(properties));\n    }\n  }, {\n    key: 'setAttributes',\n    value: function setAttributes(state, layerID, holeID, holesAttributes) {\n\n      var hAttr = holesAttributes.toJS();\n      var offsetA = hAttr.offsetA,\n          offsetB = hAttr.offsetB,\n          offset = hAttr.offset;\n\n\n      delete hAttr['offsetA'];\n      delete hAttr['offsetB'];\n      delete hAttr['offset'];\n\n      var misc = new Map({ _unitA: offsetA._unit, _unitB: offsetB._unit });\n\n      state = state.mergeIn(['scene', 'layers', layerID, 'holes', holeID], fromJS(hAttr)).mergeDeepIn(['scene', 'layers', layerID, 'holes', holeID], new Map({ offset: offset, misc: misc }));\n\n      return { updatedState: state };\n    }\n  }]);\n\n  return Hole;\n}();\n\nexport { Hole as default };"]},"metadata":{},"sourceType":"module"}