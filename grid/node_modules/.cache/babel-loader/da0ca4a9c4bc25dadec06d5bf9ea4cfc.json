{"ast":null,"code":"'use strict';\n\nvar Immutable = require('immutable');\n\nvar path = require('./path');\n\nvar tryParseInt = function (n) {\n  var int = parseInt(n);\n  return isNaN(int) ? n : int;\n};\n\nvar primitivePatch = function (op, value) {\n  if (op === 'add' || op === 'replace') {\n    return value;\n  } else if (op === 'remove') {\n    return null;\n  }\n};\n\nvar mapPatch = function (map, firstPath, restPath, op, value) {\n  if (op === 'add') {\n    if (restPath.length > 0 && map.get(firstPath) === undefined) {\n      var baseValue = restPath[0].match(/^\\d+$/) ? Immutable.List() : Immutable.Map();\n      return map.set(firstPath, anyPatch(baseValue, restPath, op, value));\n    } else {\n      return map.set(firstPath, anyPatch(map.get(firstPath), restPath, op, value));\n    }\n  } else if (op === 'replace') {\n    if (restPath.length > 0) {\n      return map.set(firstPath, anyPatch(map.get(firstPath), restPath, op, value));\n    } else {\n      return map.set(firstPath, value);\n    }\n  } else if (op === 'remove') {\n    if (restPath.length > 0) {\n      return map.set(firstPath, anyPatch(map.get(firstPath), restPath, op, value));\n    } else {\n      return map.remove(firstPath);\n    }\n  } else {\n    throw new Error('map patch Error, unknown op: ' + op);\n  }\n};\n\nvar sequencePatch = function (sequence, firstPath, restPath, op, value) {\n  firstPath = tryParseInt(firstPath);\n\n  if (op === 'add') {\n    if (sequence.get(firstPath) === undefined) {\n      if (restPath.length > 0) {\n        var baseValue = restPath[0].match(/^\\d+$/) ? Immutable.List() : Immutable.Map();\n        return sequence.set(firstPath, anyPatch(baseValue, restPath, op, value));\n      } else {\n        // special case, add to the end\n        if (firstPath === '-') {\n          return sequence.splice(sequence.size, 0, value);\n        } // special case, return the value\n\n\n        return sequence.splice(firstPath, 0, value);\n      }\n    } else {\n      if (restPath.length > 0) {\n        return sequence.set(firstPath, anyPatch(sequence.get(firstPath), restPath, op, value));\n      } else {\n        // special case, return the value\n        return sequence.splice(firstPath, 0, value);\n      }\n    }\n  } else if (op === 'replace') {\n    if (restPath.length > 0) {\n      return sequence.set(firstPath, anyPatch(sequence.get(firstPath), restPath, op, value));\n    } else {\n      return sequence.set(firstPath, value);\n    }\n  } else if (op === 'remove') {\n    if (restPath.length > 0) {\n      return sequence.set(firstPath, anyPatch(sequence.get(firstPath), restPath, op, value));\n    } else {\n      return sequence.remove(firstPath);\n    }\n  } else {\n    throw new Error('sequence patch Error, unknown op: ' + op);\n  }\n};\n\nvar isRecord = function (any) {\n  return any != null && typeof any.updateIn === 'function' && typeof any.set === 'function';\n};\n\nvar anyPatch = function (any, pathArray, op, value) {\n  var firstPath, restPath;\n\n  if (Immutable.Iterable.isIndexed(any)) {\n    if (pathArray.length === 0) {\n      return any;\n    }\n\n    firstPath = pathArray[0];\n    restPath = pathArray.slice(1);\n    return sequencePatch(any, firstPath, restPath, op, value);\n  } else if (Immutable.Iterable.isKeyed(any) || isRecord(any)) {\n    // if the object is a record or a keyed iterable immutable object\n    if (pathArray.length === 0) {\n      return any;\n    }\n\n    firstPath = pathArray[0];\n    restPath = pathArray.slice(1);\n    return mapPatch(any, firstPath, restPath, op, value);\n  } else {\n    if (pathArray.length === 0) {\n      return value;\n    }\n\n    return primitivePatch(op, value);\n  }\n};\n\nvar eachPatchInternal = function (value, patches) {\n  while (patches.size) {\n    var firstPatch = patches.get(0);\n    var patches = patches.slice(1);\n    var pathArray = firstPatch.get('path').split('/').slice(1).map(path.unescape);\n    value = anyPatch(value, pathArray, firstPatch.get('op'), firstPatch.get('value'));\n  }\n\n  return value;\n};\n\nvar eachPatch = function (value, patches) {\n  if (patches.size === 1) {\n    var onlyPatch = patches.get(0);\n\n    if (onlyPatch.get('op') === 'replace' && onlyPatch.get('path') === '/') {\n      return onlyPatch.get('value');\n    }\n  }\n\n  return eachPatchInternal(value, patches);\n};\n\neachPatch.default = eachPatch;\nmodule.exports = eachPatch;","map":{"version":3,"sources":["/home/srihari/Desktop/Sparkplug_PandemicSparks/grid/node_modules/react-planner/node_modules/immutablepatch/src/patch.js"],"names":["Immutable","require","path","tryParseInt","n","int","parseInt","isNaN","primitivePatch","op","value","mapPatch","map","firstPath","restPath","length","get","undefined","baseValue","match","List","Map","set","anyPatch","remove","Error","sequencePatch","sequence","splice","size","isRecord","any","updateIn","pathArray","Iterable","isIndexed","slice","isKeyed","eachPatchInternal","patches","firstPatch","split","unescape","eachPatch","onlyPatch","default","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Immutable = require('immutable');\nvar path = require('./path');\n\nvar tryParseInt = function(n) {\n  var int = parseInt(n);\n  return isNaN(int) ? n : int;\n};\n\nvar primitivePatch = function (op, value) {\n  if (op === 'add' || op === 'replace') {\n    return value;\n  } else if (op === 'remove') {\n    return null;\n  }\n};\n\nvar mapPatch = function(map, firstPath, restPath, op, value) {\n  if (op === 'add') {\n    if (restPath.length > 0 && map.get(firstPath) === undefined) {\n      var baseValue = (restPath[0].match(/^\\d+$/)) ? Immutable.List() : Immutable.Map();\n      return map.set(firstPath, anyPatch(baseValue, restPath, op, value));\n    } else {\n      return map.set(firstPath, anyPatch(map.get(firstPath), restPath, op, value));\n    }\n  } else if (op === 'replace') {\n    if (restPath.length > 0) {\n      return map.set(firstPath, anyPatch(map.get(firstPath), restPath, op, value));\n    } else {\n      return map.set(firstPath, value);\n    }\n  } else if (op === 'remove') {\n    if (restPath.length > 0) {\n      return map.set(firstPath, anyPatch(map.get(firstPath), restPath, op, value));\n    } else {\n      return map.remove(firstPath);\n    }\n  } else {\n    throw new Error('map patch Error, unknown op: ' + op);\n  }\n};\n\nvar sequencePatch = function(sequence, firstPath, restPath, op, value) {\n  firstPath = tryParseInt(firstPath);\n  if (op === 'add') {\n    if (sequence.get(firstPath) === undefined) {\n      if (restPath.length > 0) {\n        var baseValue = (restPath[0].match(/^\\d+$/)) ? Immutable.List() : Immutable.Map();\n        return sequence.set(firstPath, anyPatch(baseValue, restPath, op, value));\n      } else {\n        // special case, add to the end\n        if (firstPath === '-') {\n          return sequence.splice(sequence.size, 0, value);\n        }\n        // special case, return the value\n        return sequence.splice(firstPath, 0, value);\n      }\n    } else {\n      if (restPath.length > 0) {\n        return sequence.set(firstPath, anyPatch(sequence.get(firstPath), restPath, op, value));\n      } else {\n        // special case, return the value\n        return sequence.splice(firstPath, 0, value);\n      }\n    }\n  } else if (op === 'replace') {\n    if (restPath.length > 0) {\n      return sequence.set(firstPath, anyPatch(sequence.get(firstPath), restPath, op, value));\n    } else {\n      return sequence.set(firstPath, value);\n    }\n  } else if (op === 'remove') {\n    if (restPath.length > 0) {\n      return sequence.set(firstPath, anyPatch(sequence.get(firstPath), restPath, op, value));\n    } else {\n      return sequence.remove(firstPath);\n    }\n  } else {\n    throw new Error('sequence patch Error, unknown op: ' + op);\n  }\n};\n\nvar isRecord = function(any) {\n  return (\n    any != null\n    && typeof any.updateIn === 'function'\n    && typeof any.set === 'function'\n  )\n}\n\nvar anyPatch = function(any, pathArray, op, value) {\n  var firstPath, restPath;\n\n  if (Immutable.Iterable.isIndexed(any)) {\n   if (pathArray.length === 0) { return any; }\n   firstPath = pathArray[0];\n   restPath = pathArray.slice(1);\n   return sequencePatch(any, firstPath, restPath, op, value);\n  } else if (Immutable.Iterable.isKeyed(any) || isRecord(any)) {\n    // if the object is a record or a keyed iterable immutable object\n    if (pathArray.length === 0) { return any; }\n    firstPath = pathArray[0];\n    restPath = pathArray.slice(1);\n    return mapPatch(any, firstPath, restPath, op, value);\n  } else {\n    if (pathArray.length === 0) { return value; }\n    return primitivePatch(op, value);\n  }\n};\n\nvar eachPatchInternal = function(value, patches) {\n  while (patches.size) {\n    var firstPatch = patches.get(0);\n    var patches = patches.slice(1);\n    var pathArray = firstPatch.get('path').split('/').slice(1).map(path.unescape);\n    value = anyPatch(value, pathArray, firstPatch.get('op'), firstPatch.get('value'));\n  }\n  return value;\n};\n\nvar eachPatch = function(value, patches) {\n  if (patches.size === 1) {\n    var onlyPatch = patches.get(0);\n    if (onlyPatch.get('op') === 'replace' && onlyPatch.get('path') === '/') {\n      return onlyPatch.get('value');\n    }\n  }\n  return eachPatchInternal(value, patches);\n};\n\neachPatch.default = eachPatch;\nmodule.exports = eachPatch;\n"]},"metadata":{},"sourceType":"script"}